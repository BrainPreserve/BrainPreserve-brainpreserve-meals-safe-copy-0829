<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Brain Healthy Meal Generator — Tables Enabled</title>

  <!-- Your existing stylesheet (unchanged) -->
  <link rel="stylesheet" href="style.css" />

  <style>
    /* Light, unobtrusive table styles to mimic markdown tables */
    .bp-table{ border-collapse:collapse; width:100%; margin:12px 0 18px 0; font-size:14px; }
    .bp-table th,.bp-table td{ border:1px solid #e5e7eb; padding:6px 8px; vertical-align:top; }
    .bp-table th{ background:#f7f7fb; font-weight:600; }
    .bp-total td{ font-weight:700; background:#f9fafb; }
    .bp-footnote{ color:#667085; font-size:12px; margin:-6px 0 12px 0; }
    .bp5stack h3{ margin:18px 0 8px 0; }
    .bp-wrap { max-width: 980px; margin: 0 auto; padding: 0 16px; }
    th { word-break: break-word; }
  </style>

  <!-- PapaParse for robust CSV parsing -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <!-- Your existing app logic (unchanged). Keep "defer" so it initializes normally. -->
  <script defer src="app.js"></script>
</head>
<body>
  <!-- Minimal wrapper. Your own app.js will render your normal UI and recipes as usual. -->
  <main class="bp-wrap" id="app-root">
    <!-- Your existing app content will appear here (or wherever your app.js renders it). -->
    <noscript>This app requires JavaScript.</noscript>
  </main>

  <!-- CSV-backed 5-table injector (uses your 10 CSVs; no edits to your code required) -->
  <script>
  (function(){
    // ---------- FILES: exact names you provided (located in /data/) ----------
    const CSV_FILES = [
      'categories.csv',
      'diet_tool.csv',
      'fiber.csv',
      'gi_gl.csv',
      'main.csv',
      'microbiome.csv',
      'micronutrients_list.csv',
      'micronutrients_food.csv',
      'moder.csv',
      'protein.csv'
    ].map(n => '/data/' + n);

    // ---------- COLUMN ALIASES (covers common header variants across files) ----------
    const COLS = {
      ingredient:     ['Ingredient','Food','Item','Name'],
      calories:       ['Calories','kcal','Calories_per_serving'],
      protein_g:      ['Protein (g)','Protein_g','Protein'],
      fiber_g:        ['Fiber (g)','Fiber_g','Fiber'],
      gi:             ['GI','Glycemic Index'],
      gl:             ['GL','Glycemic Load'],
      dii:            ['DII Score','DII','AntiInflammatoryScore','Anti-Inflammatory/DII','Anti-Inflammatory/DII Score (lower is better)'],
      key_micros:     ['Key Micronutrients','Key Nutrients/Bioactives','Key_Nutrients'],
      micro_type:     ['Microbiome Prebiotic or Probiotic or Postbiotic','Microbiome_Type','Pre/Pro/Postbiotic','Microbiome Type'],
      micro_score:    ['Microbiome Benefit Score','Microbiome_Score','Benefit Score'],
      cog_benefits:   ['Cognitive Benefits & Mechanisms','Cognitive_Benefits','Cognition_Mechanisms'],
      other_benefits: ['Other Health Benefits','Other_Benefits'],
      diets_list:     ['Compatible Diets','Diets','Diet_Compat'],
      serving_size:   ['Serving Size','Serving','Common Serving'],
      mech_fn:        ['Mechanism/Function','Mechanism','Function'],
      sources_details:['Notable Sources/Details','Notes','Details']
    };

    // If your diet CSV uses booleans per diet, we’ll stitch a list from these columns when needed:
    const POSSIBLE_DIETS = ['MIND','Mediterranean','DASH','LowGI','Pescetarian','Vegetarian','Vegan','Keto','Paleo','GlutenFree','DairyFree','AntiInflammatory','Modern'];

    const STATE = { db:{}, loaded:false, marked:new WeakSet() };

    // ---------- helpers ----------
    const escapeHTML = s => String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
    const toKey = s => (s||'').toLowerCase().normalize('NFKD').replace(/[\u0300-\u036f]/g,'').replace(/[^a-z0-9\s\-]/g,'').replace(/\s+/g,' ').trim();
    const num = v => {
      if (v==null) return null;
      const x = parseFloat(String(v).replace(/[^\d\.\-]/g,''));
      return Number.isFinite(x) ? x : null;
    };
    const fmt = (v,d=0) => (v==null || !Number.isFinite(v) ? 'N/A' : (d===0 ? String(Math.round(v)) : v.toFixed(d)));
    const pick = (row, names) => { for (const n of names) if (n in row && row[n]!=='' && row[n]!=null) return row[n]; };
    const ensureArray = v => Array.isArray(v) ? v : (v==null ? [] : String(v).split(/[,;\/\|]/).map(s=>s.trim()).filter(Boolean));

    // Light name normalization (extend as needed)
    const NAME_ALIAS = {
      'extra virgin olive oil':'olive oil','ev olive oil':'olive oil','rolled oats':'oats','baby spinach':'spinach',
      'greek yogurt':'yogurt','brown rice':'rice','wild salmon':'salmon','chickpeas':'garbanzo beans'
    };
    const canonical = raw => {
      let s = String(raw||'').toLowerCase();
      s = s.replace(/\(.*?\)/g,'').replace(/\b(fresh|chopped|diced|minced|cooked|raw|organic|extra|virgin|ground|dry|dried|toasted|unsalted|salted|low\-fat|nonfat|skinless|boneless)\b/g,'');
      s = s.replace(/\s+/g,' ').trim();
      if (NAME_ALIAS[s]) s = NAME_ALIAS[s];
      if (s.endsWith('s') && !s.endsWith('ss')) s = s.slice(0,-1);
      return s;
    };

    // ---------- CSV loading/merge ----------
    function loadAll() {
      return new Promise(res=>{
        let left = CSV_FILES.length;
        CSV_FILES.forEach(u=>{
          Papa.parse(u,{download:true,header:true,skipEmptyLines:'greedy',
            complete:(r)=>{ if (Array.isArray(r.data)) merge(r.data); if(--left===0){STATE.loaded=true;res();}},
            error:()=>{ if(--left===0){STATE.loaded=true;res();} }
          });
        });
      });
    }

    function merge(rows){
      for (const r0 of rows){ if(!r0) continue;
        const r = {};
        for (const k in r0) r[k.trim()] = r0[k];
        const name = pick(r, COLS.ingredient);
        if(!name) continue;
        const key = toKey(canonical(name));
        if(!STATE.db[key]) STATE.db[key] = { _name:name, _rows:[] };
        const dst = STATE.db[key];
        dst._rows.push(r);

        // prefer-first merge for key fields
        const groups = [
          ['calories',COLS.calories],['protein_g',COLS.protein_g],['fiber_g',COLS.fiber_g],
          ['gi',COLS.gi],['gl',COLS.gl],['dii',COLS.dii],['key_micros',COLS.key_micros],
          ['micro_type',COLS.micro_type],['micro_score',COLS.micro_score],['cog_benefits',COLS.cog_benefits],
          ['other_benefits',COLS.other_benefits],['diets_list',COLS.diets_list],
          ['serving_size',COLS.serving_size],['mech_fn',COLS.mech_fn],['sources_details',COLS.sources_details]
        ];
        for (const [k,aliases] of groups){
          if (dst[k]==null){
            const v = pick(r, aliases);
            if (v!=null && String(v).trim()!=='') dst[k]=v;
          }
        }
      }
    }

    // ---------- observe recipes and inject tables ----------
    function observe(){
      // initial sweep + future updates
      const scan = root => {
        const heads = root.querySelectorAll('h2,h3,h4,strong,b,div,span');
        heads.forEach(h=>{
          if (STATE.marked.has(h)) return;
          const t = (h.textContent||'').toLowerCase().trim();
          if (!/^\s*ingredients\s*:?/.test(t)) return;
          // find the list after the heading
          let list = h.nextElementSibling;
          while (list && !(list.tagName==='UL' || list.tagName==='OL')) {
            if (/^H[1-6]$/.test(list.tagName)) { list=null; break; }
            list = list.nextElementSibling;
          }
          if (!list || !(list.tagName==='UL'||list.tagName==='OL') || list.children.length===0) return;

          // Skip if already injected
          if (list.nextElementSibling && list.nextElementSibling.classList && list.nextElementSibling.classList.contains('bp5stack')) {
            STATE.marked.add(h); return;
          }
          injectTables(list);
          STATE.marked.add(h);
        });
      };

      const mo = new MutationObserver(muts=>{
        muts.forEach(m=>{
          (m.addedNodes||[]).forEach(n=>{
            if (n.nodeType===1) scan(n);
          });
        });
      });
      mo.observe(document.body,{childList:true,subtree:true});
      scan(document);
    }

    function parseIngredients(list){
      const out=[];
      list.querySelectorAll('li').forEach(li=>{
        const raw=(li.textContent||'').trim();
        if(!raw) return;
        // very light parse for amount/unit; keep for future %RDA work
        const m = raw.match(/^([\d\/\.\,\s\-]+)?\s*([a-zA-Zµ]+)?\s*(.*)$/);
        let qty=null,unit=null,namePart=raw;
        if(m){ qty = fracToFloat(m[1]); unit = m[2]?m[2].toLowerCase():null; namePart = m[3]||raw; }
        const name = canonical(namePart);
        if (name) out.push({ raw,name,qty,unit });
      });
      return out;
    }

    function fracToFloat(s){
      if(!s) return null;
      const parts = String(s).trim().split(/\s+/);
      let total=0;
      for (const p of parts){
        if (p.includes('/')){ const [a,b]=p.split('/').map(Number); if(Number.isFinite(a)&&Number.isFinite(b)&&b!==0) total+=a/b; }
        else { const v=parseFloat(p); if(Number.isFinite(v)) total+=v; }
      }
      return Number.isFinite(total)&&total>0 ? total : null;
    }

    function attachDB(item){
      const key = toKey(item.name);
      const rec = STATE.db[key] || null;
      const display = rec? (rec._name || item.raw || item.name) : (item.raw || item.name);
      return { ...item, rec, display };
    }

    // ---------- Table builders (exact order/headers) ----------
    function injectTables(listEl){
      if(!STATE.loaded) return;
      const items = parseIngredients(listEl);
      if(!items.length) return;

      const rows = items.map(attachDB).sort((a,b)=>a.display.localeCompare(b.display));

      const t1 = buildNutritionTable(rows);
      const t2 = buildCogTable(rows);
      const t3 = buildDietTable(rows);
      const t4 = buildMicrobiomeTable(rows);
      const t5 = buildMicronutrientBenefitsTable(rows);

      const wrap = document.createElement('div');
      wrap.className = 'bp5stack';
      wrap.innerHTML = [t1,t2,t3,t4,t5].join('\n');
      listEl.insertAdjacentElement('afterend', wrap);
    }

    function buildNutritionTable(rows){
      let totCal=0, totProt=0, totFib=0, totGL=0;
      const body = rows.map(r=>{
        const d = r.rec||{};
        const cal=num(d.calories); if(cal!=null) totCal+=cal;
        const pr=num(d.protein_g); if(pr!=null) totProt+=pr;
        const fi=num(d.fiber_g);   if(fi!=null) totFib+=fi;
        const gi=num(d.gi);
        const gl=num(d.gl);        if(gl!=null) totGL+=gl;
        const dii = (d.dii!=null && String(d.dii).trim()!=='') ? d.dii : 'N/A';
        const keyMicros = d.key_micros ?? 'N/A';
        const mType = d.micro_type ?? 'N/A';
        const mScore = d.micro_score ?? 'N/A';

        return `<tr>
          <td>${escapeHTML(r.display)}</td>
          <td>${fmt(cal)}</td>
          <td>${fmt(pr)}</td>
          <td>${fmt(fi)}</td>
          <td>${gi==null?'N/A':fmt(gi)}</td>
          <td>${gl==null?'N/A':fmt(gl)}</td>
          <td>${escapeHTML(String(dii))}</td>
          <td>${escapeHTML(String(keyMicros))}</td>
          <td>${escapeHTML(String(mType))}</td>
          <td>${escapeHTML(String(mScore))}</td>
        </tr>`;
      }).join('');

      const totals = `<tr class="bp-total">
        <td>Totals</td>
        <td>${fmt(totCal)}</td>
        <td>${fmt(totProt)}</td>
        <td>${fmt(totFib)}</td>
        <td>—</td>
        <td>${fmt(totGL)}</td>
        <td>—</td>
        <td>—</td>
        <td>—</td>
        <td>—</td>
      </tr>`;

      return `
        <h3>1. Nutrition Table</h3>
        <table class="bp-table">
          <thead>
            <tr>
              <th>Ingredient</th>
              <th>Calories</th>
              <th>Protein (g)</th>
              <th>Fiber (g)</th>
              <th>GI</th>
              <th>GL</th>
              <th>Anti-Inflammatory/<wbr>DII Score<br>(lower is better)</th>
              <th>Key Micronutrients</th>
              <th>Microbiome Prebiotic or Probiotic or Postbiotic</th>
              <th>Microbiome Benefit Score</th>
            </tr>
          </thead>
          <tbody>${body}${totals}</tbody>
        </table>
        <div class="bp-footnote">Note: Totals sum Calories, Protein, Fiber, and GL. GI and DII are not additive and are shown as “—”. “N/A” appears when data are unavailable in your CSVs.</div>
      `;
    }

    function buildCogTable(rows){
      const body = rows.map(r=>{
        const d=r.rec||{};
        return `<tr>
          <td>${escapeHTML(r.display)}</td>
          <td>${escapeHTML(d.cog_benefits ?? 'N/A')}</td>
          <td>${escapeHTML(d.other_benefits ?? 'N/A')}</td>
        </tr>`;
      }).join('');
      return `
        <h3>2. Cognitive &amp; Other Health Benefits Table</h3>
        <table class="bp-table">
          <thead><tr><th>Ingredient</th><th>Cognitive Benefits &amp; Mechanisms</th><th>Other Health Benefits</th></tr></thead>
          <tbody>${body}</tbody>
        </table>
      `;
    }

    function buildDietTable(rows){
      const body = rows.map(r=>{
        const d=r.rec||{};
        let diets = d.diets_list;
        if (!diets) diets = deriveDietList(d._rows || []);
        return `<tr><td>${escapeHTML(r.display)}</td><td>${escapeHTML(diets ? String(diets) : 'N/A')}</td></tr>`;
      }).join('');
      return `
        <h3>3. Diet Compatibility Table</h3>
        <table class="bp-table">
          <thead><tr><th>Ingredient</th><th>Compatible Diets</th></tr></thead>
          <tbody>${body}</tbody>
        </table>
      `;
    }

    function deriveDietList(rows){
      if(!rows.length) return null;
      const yes=new Set();
      for (const r of rows){
        for (const d of POSSIBLE_DIETS){
          if (d in r){
            const v = String(r[d]).toLowerCase();
            if (['1','y','yes','true','✓','x'].includes(v)) yes.add(d);
          }
        }
      }
      return yes.size ? Array.from(yes).sort().join(', ') : null;
    }

    function buildMicrobiomeTable(rows){
      const body = rows.map(r=>{
        const d=r.rec||{};
        return `<tr>
          <td>${escapeHTML(r.display)}</td>
          <td>${escapeHTML(d.micro_type ?? 'N/A')}</td>
          <td>${escapeHTML(d.micro_score ?? 'N/A')}</td>
        </tr>`;
      }).join('');
      return `
        <h3>4. Microbiome Benefit Table</h3>
        <table class="bp-table">
          <thead><tr><th>Ingredient</th><th>Microbiome Prebiotic or Probiotic or Postbiotic</th><th>Microbiome Benefit Score</th></tr></thead>
          <tbody>${body}</tbody>
        </table>
      `;
    }

    function buildMicronutrientBenefitsTable(rows){
      const body = rows.map(r=>{
        const d=r.rec||{};
        const serving = d.serving_size ?? 'N/A';
        const keyN = d.key_micros ?? 'N/A';
        const mech = d.mech_fn ?? 'N/A';
        const srcs = d.sources_details ?? 'N/A';
        const pct = estimatePercentRDA(d); // best-effort; returns null if not computable
        return `<tr>
          <td>${escapeHTML(r.display)}</td>
          <td>${escapeHTML(serving)}</td>
          <td>${escapeHTML(keyN)}</td>
          <td>${escapeHTML(mech)}</td>
          <td>${escapeHTML(srcs)}</td>
          <td>${escapeHTML(pct ?? 'N/A')}</td>
        </tr>`;
      }).join('');
      return `
        <h3>5. Micronutrient Benefits Table</h3>
        <table class="bp-table">
          <thead>
            <tr>
              <th>Ingredient</th>
              <th>Serving Size</th>
              <th>Key Nutrients/Bioactives</th>
              <th>Mechanism/Function</th>
              <th>Notable Sources/Details</th>
              <th>% Recommended Daily Amount</th>
            </tr>
          </thead>
          <tbody>${body}</tbody>
        </table>
        <div class="bp-footnote">Note: %RDA is shown only when a computable field is present across your CSVs; otherwise “N/A”.</div>
      `;
    }

    // Best-effort %RDA look-up. If your CSVs expose a finished %RDA value, this will pick it up.
    function estimatePercentRDA(rec){
      try{
        const rows = rec._rows || [];
        for (const row of rows){
          for (const k in row){
            const key = k.toLowerCase();
            if (/%\s*rda/.test(key) || /rda_%/.test(key) || /percent[_\s]?rda/.test(key)){
              const v = num(row[k]);
              if (v!=null) return fmt(v);
            }
          }
        }
        return null;
      } catch { return null; }
    }

    // ---------- startup ----------
    function start(){
      loadAll().then(()=>{ STATE.loaded=true; observe(); });
    }
    document.addEventListener('DOMContentLoaded', start);
  })();
  </script>
</body>
</html>
