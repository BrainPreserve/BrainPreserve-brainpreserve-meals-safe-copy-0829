<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Brain‑Healthy Meal Generator — Standalone (CSV + Mapping)</title>
  <style>
    :root{ --bg:#f7f8fb; --fg:#111; --muted:#667085; --card:#fff; --line:#e5e7eb; --accent:#0a60ff; }
    *{box-sizing:border-box}
    body{font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;margin:0;background:var(--bg);color:var(--fg)}
    main{max-width:1100px;margin:28px auto;padding:0 16px}
    h1{margin:0 0 8px}
    .card{background:var(--card);border:1px solid var(--line);border-radius:16px;padding:16px;margin:12px 0}
    label{display:block;font-weight:600;margin:8px 0 6px}
    textarea{width:100%;padding:10px;border:1px solid var(--line);border-radius:10px}
    button{border:0;background:var(--accent);color:#fff;padding:10px 14px;border-radius:12px;font-weight:700;cursor:pointer}
    table{width:100%;border-collapse:collapse;margin:10px 0;border:1px solid var(--line)}
    th,td{border:1px solid var(--line);padding:8px;text-align:left;vertical-align:top}
    th{background:#f2f4f7}
    .muted{color:var(--muted);font-size:14px}
    .chip{display:inline-block;border:1px solid var(--line);padding:2px 8px;border-radius:999px;margin:2px 6px 2px 0;background:#fff}
    details{margin:8px 0}
    .ok{color:#0d9488}.warn{color:#c2410c}.bad{color:#b91c1c}
    code{background:#eef2ff;padding:2px 6px;border-radius:6px}
  </style>
</head>
<body>
  <main>
    <h1>Tables Builder (CSV → 5 Tables via Mapping)</h1>
    <p class="muted">Novice‑mode: this page <b>auto‑loads</b> everything from your repo’s <code>/data/</code> folder. You don’t paste URLs.</p>

    <div class="card">
      <h2>1) Status</h2>
      <div id="status" class="muted">Checking /data/…</div>
    </div>

    <div class="card">
      <h2>2) Ingredients / Recipe</h2>
      <label>Type comma‑separated ingredients (restricted to items found in your whitelisted files)</label>
      <textarea id="ingredients_input" rows="3" placeholder="eggs, spinach, cherry tomatoes, olive oil"></textarea>
      <div style="margin-top:10px;display:flex;gap:8px;align-items:center">
        <button id="btn_build">Build Tables</button>
        <button id="btn_clear" style="background:#475569">Clear</button>
        <span class="muted">Parsed items: <span id="parsed"></span></span>
      </div>
    </div>

    <div class="card">
      <h2>3) Output</h2>
      <div id="warnings" class="muted"></div>
      <div id="tables"></div>
    </div>

    <details class="card">
      <summary><b>How this works</b></summary>
      <ul>
        <li>Reads <b>settings_global.csv</b> for <i>join key</i> (default <code>Foods</code> with alias <code>Food</code>) and <i>whitelist</i> (e.g., <code>main.csv|categories.csv</code>).</li>
        <li>Reads the 5 mapping CSVs to know which file/column populates each output column. Modes:
          <ul>
            <li><b>priority_fallback</b>: use the first non‑empty source, else fallbacks.</li>
            <li><b>combine</b>: merge all non‑empty sources, de‑duplicate, join with separator (e.g., <code>; </code>).</li>
          </ul>
        </li>
        <li>Truthy ✓ flags: ✓, ✔, yes, true, y, 1 (case‑insensitive).</li>
        <li>Whitelist: only foods present in the listed files are allowed.</li>
      </ul>
    </details>
  </main>

<script>
const $ = id => document.getElementById(id);
const norm = s => (s||'').toLowerCase().replace(/[^a-z0-9+\s]/g,'').replace(/\s+/g,' ').trim();
const truthy = v => {
  const t = (v||'').toString().toLowerCase().trim();
  return ['✓','✔','yes','true','y','1'].some(x=>t===x || (v||'').toString().includes('✓'));
};

function parseCSV(text){
  const rows=[]; let row=[]; let cell=''; let q=false;
  for(let i=0;i<text.length;i++){
    const c=text[i]; const n=text[i+1];
    if(c==='"'){
      if(q && n==='"'){ cell+='"'; i++; }
      else { q=!q; }
    } else if(c===',' && !q){ row.push(cell); cell=''; }
    else if((c==='
' || c==='
') && !q){ if(cell!==''||row.length){ row.push(cell); rows.push(row); row=[]; cell=''; } }
    else { cell+=c; }
  }
  if(cell!==''||row.length){ row.push(cell); rows.push(row); }
  if(!rows.length) return {headers:[], data:[]};
  const headers = rows[0].map(h=>h.trim());
  const data = rows.slice(1).filter(r=>r.some(x=>x!=='')).map(r=>Object.fromEntries(headers.map((h,i)=>[h, r[i]!==undefined?r[i].trim():'' ])));
  return {headers, data};
}

async function fetchCSV(path){
  const res = await fetch(path, {cache:'no-store'});
  if(!res.ok) throw new Error(`${path} (${res.status})`);
  return parseCSV(await res.text());
}

const DATA_BASE = './data/';
const MAPPING_FILES = {
  nutrition: 'mapping_nutrition.csv',
  cog_other: 'mapping_cognitive_other.csv',
  diet_compat: 'mapping_diet_compat.csv',
  microbiome: 'mapping_microbiome.csv',
  micronutrients: 'mapping_micronutrients.csv'
};

async function loadSettings(){
  let joinKey = 'Foods';
  let whitelist = ['main.csv','categories.csv'];
  try{
    const s = await fetchCSV(DATA_BASE+'settings_global.csv');
    for(const r of s.data){
      if((r.setting||'').toLowerCase()==='joinkey' && r.value) joinKey = r.value.trim();
      if((r.setting||'').toLowerCase()==='whitelist' && r.value) whitelist = r.value.split('|').map(x=>x.trim()).filter(Boolean);
    }
  }catch(e){}
  return {joinKey, whitelist, joinKeyAliases: ['Foods','Food']};
}

async function loadMappings(){
  const rows=[]; const missing=[];
  for(const [key,file] of Object.entries(MAPPING_FILES)){
    try{
      const m = await fetchCSV(DATA_BASE+file);
      for(const r of m.data){ r.__table = key; rows.push(r); }
    }catch(e){ missing.push(file); }
  }
  return {rows, missing};
}

function detectKey(headers, pref, aliases){
  if(headers.includes(pref)) return pref;
  for(const a of aliases){ if(headers.includes(a)) return a; }
  for(const g of ['Ingredient','ingredient','item','Item']){ if(headers.includes(g)) return g; }
  return pref;
}

function groupBy(arr, key){ const m=new Map(); for(const r of arr){ const k=r[key]; if(!m.has(k)) m.set(k,[]); m.get(k).push(r);} return m; }

async function loadDataFiles(mappingRows, settings){
  const needed = new Set();
  for(const r of mappingRows){ if(r.file) needed.add(r.file.trim()); }
  for(const w of settings.whitelist){ needed.add(w.trim()); }

  const datasets = {};
  for(const file of needed){
    try{
      const csv = await fetchCSV(DATA_BASE+file);
      const keyName = detectKey(csv.headers, settings.joinKey, settings.joinKeyAliases);
      const idx = new Map();
      for(const row of csv.data){ const k = norm(row[keyName]); if(k) idx.set(k,row); }
      datasets[file] = { headers: csv.headers, rows: csv.data, index: idx, keyName };
    }catch(e){ datasets[file] = { error: e.message } }
  }
  return datasets;
}

function renderTable(title, headers, rows){
  const tbl = document.createElement('table');
  const thead = document.createElement('thead');
  const trh = document.createElement('tr');
  headers.forEach(h=>{ const th=document.createElement('th'); th.textContent=h; trh.appendChild(th); });
  thead.appendChild(trh); tbl.appendChild(thead);
  const tbody = document.createElement('tbody');
  for(const r of rows){ const tr=document.createElement('tr'); for(const h of headers){ const td=document.createElement('td'); td.textContent = r[h] ?? 'N/A'; tr.appendChild(td);} tbody.appendChild(tr);} tbl.appendChild(tbody);
  const wrap=document.createElement('div');
  const h2=document.createElement('h3'); h2.textContent=title; wrap.appendChild(h2); wrap.appendChild(tbl);
  return wrap;
}

function extractIngredients(text){
  const raw = text.split(/[\n,;]+/g).map(s=>s.trim()).filter(Boolean);
  const seen=new Set(); const out=[]; for(const r of raw){ const k=norm(r); if(k && !seen.has(k)){ seen.add(k); out.push(r); } }
  return out;
}

function cellValue(row, col){ if(!row) return ''; let v = row[col]; return (v===undefined||v===null)?'':String(v).trim(); }

function resolvePriorityFallback(sources, itemKey, datasets, tableKey, outHeader){
  for(const s of sources.sort((a,b)=>Number(a.order)-Number(b.order))){
    const ds = datasets[s.file]; if(!ds || ds.error) continue; const row = ds.index.get(itemKey); const val = cellValue(row, s.csv_column);
    if(!val) continue;
    if(outHeader.toLowerCase().includes('anti-inflammatory') && s.role!== 'primary'){
      if(truthy(val)) return '✓ anti-inflammatory (no score)'; else continue;
    }
    if(tableKey==='diet_compat' && s.csv_column && s.csv_column.includes('✓')){
      return truthy(val) ? 'Yes' : 'No';
    }
    return val;
  }
  return 'N/A';
}

function resolveCombine(sources, itemKey, datasets){
  const vals=[]; let sep='; ';
  for(const s of sources.sort((a,b)=>Number(a.order)-Number(b.order))){
    const ds = datasets[s.file]; if(!ds || ds.error) continue; const row = ds.index.get(itemKey); const val = cellValue(row, s.csv_column);
    if(val){ if(s.combine_separator) sep=s.combine_separator; if(!vals.includes(val)) vals.push(val); }
  }
  return vals.length? vals.join(sep) : 'N/A';
}

function buildHeadersForTable(mappingRows){
  const headers = new Set(['Ingredient/Food']);
  for(const r of mappingRows){ if(r.output_header && r.output_header !== 'Ingredient/Food') headers.add(r.output_header); }
  return Array.from(headers);
}

async function build(){
  const status = $('status'); const warnings = $('warnings'); const out = $('tables');
  warnings.innerHTML=''; out.innerHTML='';

  const ingredients = extractIngredients($('ingredients_input').value.trim());
  $('parsed').innerHTML = ingredients.map(x=>`<span class="chip">${x}</span>`).join('');

  let settings, mappingLoad; 
  try { settings = await loadSettings(); mappingLoad = await loadMappings(); }
  catch(e){ status.innerHTML = `<span class="bad">Failed to load settings/mappings: ${e.message}</span>`; return; }

  if(mappingLoad.missing.length){ status.innerHTML = `<span class="warn">Missing mapping files:</span> ${mappingLoad.missing.join(', ')}. Continue with available.`; }
  else { status.innerHTML = `<span class="ok">✔ Found all mapping files.</span>`; }

  const datasets = await loadDataFiles(mappingLoad.rows, settings);

  const allowed = new Set();
  for(const f of settings.whitelist){ const ds = datasets[f]; if(!ds||ds.error) continue; for(const row of ds.rows){ const k = norm(row[ds.keyName]); if(k) allowed.add(k); } }

  const accepted=[]; const blocked=[];
  for(const raw of ingredients){ const k = norm(raw); if(allowed.has(k)) accepted.push({raw, key:k}); else blocked.push(raw); }
  if(blocked.length){ warnings.innerHTML += `<div><span class="warn">Blocked by whitelist:</span> ${blocked.join(', ')}.</div>`; }
  if(!accepted.length){ warnings.innerHTML += `<div><span class="bad">No valid ingredients after whitelist.</span></div>`; return; }

  const byTable = groupBy(mappingLoad.rows, '__table');

  for(const [tableKey, rows] of byTable.entries()){
    const byHeader = groupBy(rows, 'output_header');
    const headers = buildHeadersForTable(rows);
    const tableRows=[];

    for(const ing of accepted){
      const rowOut = {'Ingredient/Food': ing.raw};
      for(const [outHeader, sources] of byHeader.entries()){
        if(outHeader==='Ingredient/Food') continue;
        const mode = (sources[0].mode||'priority_fallback').toLowerCase();
        let val = 'N/A';
        if(mode==='combine') val = resolveCombine(sources, ing.key, datasets);
        else val = resolvePriorityFallback(sources, ing.key, datasets, tableKey, outHeader);
        rowOut[outHeader] = val;
      }
      tableRows.push(rowOut);
    }

    const titleMap = {
      nutrition: 'Nutrition',
      cog_other: 'Cognitive & Other Health Benefits',
      diet_compat: 'Diet Compatibility',
      microbiome: 'Microbiome Benefit',
      micronutrients: 'Micronutrient Benefits'
    };
    out.appendChild(renderTable(titleMap[tableKey]||tableKey, headers, tableRows));
  }
}

document.getElementById('btn_build').addEventListener('click', build);
document.getElementById('btn_clear').addEventListener('click', ()=>{
  document.getElementById('ingredients_input').value='';
  document.getElementById('parsed').innerHTML='';
  document.getElementById('warnings').innerHTML='';
  document.getElementById('tables').innerHTML='';
});

(async ()=>{
  try{
    const s = await loadSettings();
    const m = await loadMappings();
    document.getElementById('status').innerHTML = `<div>Join key: <b>${s.joinKey}</b> (aliases: ${s.joinKeyAliases.join(', ')})</div>
      <div>Whitelist files: <b>${s.whitelist.join(', ')}</b></div>
      <div>Mapping files missing: ${m.missing.length? m.missing.join(', '): '<span class=ok>none</span>'}</div>`;
  }catch(e){ document.getElementById('status').innerHTML = `<span class=bad>Failed to read status: ${e.message}</span>`; }
})();
</script>
</body>
</html>
