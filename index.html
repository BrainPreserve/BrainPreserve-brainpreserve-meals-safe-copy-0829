<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Brain Healthy Meal Generator — Tables Enabled</title>

  <!-- Your existing stylesheet (unchanged) -->
  <link rel="stylesheet" href="style.css" />

  <style>
    /* Markdown-like tables */
    .bp-table{ border-collapse:collapse; width:100%; margin:12px 0 18px 0; font-size:14px; }
    .bp-table th,.bp-table td{ border:1px solid #e5e7eb; padding:6px 8px; vertical-align:top; }
    .bp-table th{ background:#f7f7fb; font-weight:600; }
    .bp-total td{ font-weight:700; background:#f9fafb; }
    .bp-footnote{ color:#667085; font-size:12px; margin:-6px 0 12px 0; }
    .bp5stack h3{ margin:18px 0 8px 0; }
    .bp-wrap { max-width: 980px; margin: 0 auto; padding: 0 16px; }
    th { word-break: break-word; }

    /* Tiny diagnostics banner (appears only if needed) */
    .bp-diag{position:fixed;left:12px;bottom:12px;background:#111;color:#fff;font:12px/1.2 system-ui,Segoe UI,Roboto,Arial,sans-serif;padding:8px 10px;border-radius:8px;box-shadow:0 6px 18px rgba(0,0,0,.25);opacity:.95;z-index:99999;max-width:320px}
    .bp-diag.ok{background:#0a7f2e}
    .bp-diag.warn{background:#9a6700}
    .bp-diag.err{background:#a62626}
    .bp-diag b{display:block;margin-bottom:4px}
  </style>

  <!-- PapaParse for robust CSV parsing -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <!-- Your existing app logic (unchanged) -->
  <script defer src="app.js"></script>
</head>
<body>
  <main class="bp-wrap" id="app-root">
    <noscript>This app requires JavaScript.</noscript>
  </main>

  <!-- CSV-backed 5-table injector (robust detection + dual path CSV loading) -->
  <script>
  (function(){
    // ---------- FILES you showed in /data/ ----------
    const CSV_BASENAMES = [
      'categories.csv',
      'diet_tool.csv',
      'fiber.csv',
      'gi_gl.csv',
      'main.csv',
      'microbiome.csv',
      'micronutrients_list.csv',
      'micronutrients_food.csv',
      'moder.csv',
      'protein.csv'
    ];
    const DATA_ROOTS = ['/data/', 'data/', './data/']; // try all

    // ---------- COLUMN ALIASES ----------
    const COLS = {
      ingredient:     ['Ingredient','Ingredients','Food','Item','Name','Food Name','Ingredient Name'],
      calories:       ['Calories','kcal','Calories_per_serving'],
      protein_g:      ['Protein (g)','Protein_g','Protein'],
      fiber_g:        ['Fiber (g)','Fiber_g','Fiber'],
      gi:             ['GI','Glycemic Index'],
      gl:             ['GL','Glycemic Load'],
      dii:            ['DII Score','DII','AntiInflammatoryScore','Anti-Inflammatory/DII','Anti-Inflammatory/DII Score (lower is better)'],
      key_micros:     ['Key Micronutrients','Key Nutrients/Bioactives','Key_Nutrients'],
      micro_type:     ['Microbiome Prebiotic or Probiotic or Postbiotic','Microbiome_Type','Pre/Pro/Postbiotic','Microbiome Type'],
      micro_score:    ['Microbiome Benefit Score','Microbiome_Score','Benefit Score'],
      cog_benefits:   ['Cognitive Benefits & Mechanisms','Cognitive_Benefits','Cognition_Mechanisms'],
      other_benefits: ['Other Health Benefits','Other_Benefits'],
      diets_list:     ['Compatible Diets','Diets','Diet_Compat'],
      serving_size:   ['Serving Size','Serving','Common Serving'],
      mech_fn:        ['Mechanism/Function','Mechanism','Function'],
      sources_details:['Notable Sources/Details','Notes','Details']
    };
    const POSSIBLE_DIETS = ['MIND','Mediterranean','DASH','LowGI','Pescetarian','Vegetarian','Vegan','Keto','Paleo','GlutenFree','DairyFree','AntiInflammatory','Modern'];

    const STATE = { db:{}, loaded:false, marked:new WeakSet(), csvRows:0, tablesMade:0, diagShown:false };

    // ---------- Helpers ----------
    const HEADING_REGEX = /^\s*ingredients\s*:?\s*$/i; // detects "Ingredients" or "Ingredients:"
    const escapeHTML = s => String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
    const toKey = s => (s||'').toLowerCase().normalize('NFKD').replace(/[\u0300-\u036f]/g,'').replace(/[^a-z0-9\s\-]/g,'').replace(/\s+/g,' ').trim();
    const num = v => { if(v==null) return null; const x=parseFloat(String(v).replace(/[^\d\.\-]/g,'')); return Number.isFinite(x)?x:null; };
    const fmt = (v,d=0) => (v==null || !Number.isFinite(v) ? 'N/A' : (d===0 ? String(Math.round(v)) : v.toFixed(d)));
    const pick = (row, names) => { for(const n of names){ if(n in row && row[n]!=='' && row[n]!=null) return row[n]; } };
    const NAME_ALIAS = {'extra virgin olive oil':'olive oil','ev olive oil':'olive oil','rolled oats':'oats','baby spinach':'spinach','greek yogurt':'yogurt','brown rice':'rice','wild salmon':'salmon','chickpeas':'garbanzo beans'};

    const canonical = raw => {
      let s = String(raw||'').toLowerCase();
      s = s.replace(/\(.*?\)/g,'').replace(/\b(fresh|chopped|diced|minced|cooked|raw|organic|extra|virgin|ground|dry|dried|toasted|unsalted|salted|low\-fat|nonfat|skinless|boneless)\b/g,'');
      s = s.replace(/\s+/g,' ').trim();
      if (NAME_ALIAS[s]) s = NAME_ALIAS[s];
      if (s.endsWith('s') && !s.endsWith('ss')) s = s.slice(0,-1);
      return s;
    };

    function showDiag(kind, title, msg){
      if (STATE.diagShown) return; // at most one
      const b = document.createElement('div');
      b.className = 'bp-diag ' + (kind||'warn');
      b.innerHTML = `<b>${escapeHTML(title||'Notice')}</b>${escapeHTML(msg||'')}`;
      document.body.appendChild(b);
      STATE.diagShown = true;
      setTimeout(()=>{ b.remove(); }, 8000);
    }

    // ---------- CSV loading with multi-root retry ----------
    function loadAllCSVs(){
      return new Promise(resolve=>{
        let toLoad = CSV_BASENAMES.length;
        CSV_BASENAMES.forEach(name => loadOneWithFallback(name, 0, ()=>{
          if(--toLoad===0){ STATE.loaded=true; resolve(); }
        }));
      });
    }

    function loadOneWithFallback(name, idx, done){
      if (idx >= DATA_ROOTS.length){ done(); return; }
      const url = DATA_ROOTS[idx] + name;
      Papa.parse(url, {
        download:true, header:true, skipEmptyLines:'greedy',
        complete:(res)=>{
          if (Array.isArray(res.data) && res.data.length){
            mergeRows(res.data);
            done();
          } else {
            // try next root
            loadOneWithFallback(name, idx+1, done);
          }
        },
        error:()=>{
          loadOneWithFallback(name, idx+1, done);
        }
      });
    }

    function mergeRows(rows){
      for (const r0 of rows){
        if(!r0) continue;
        const r={}; for (const k in r0) r[k.trim()] = r0[k];
        let name = pick(r, COLS.ingredient);
        // Fallbacks: use the first column that *looks* like an ingredient, else first non-empty cell.
        if (!name){
          const keys = Object.keys(r);
          const guess = keys.find(k => /ingredient|food|item|name/i.test(k));
          if (guess) name = r[guess];
          else name = r[keys[0]];
        }
        if (!name) continue;

        const key = toKey(canonical(name));
        if (!STATE.db[key]) STATE.db[key] = { _name: name, _rows: [] };
        const dst = STATE.db[key]; dst._rows.push(r); STATE.csvRows++;

        const groups = [
          ['calories',COLS.calories],['protein_g',COLS.protein_g],['fiber_g',COLS.fiber_g],
          ['gi',COLS.gi],['gl',COLS.gl],['dii',COLS.dii],['key_micros',COLS.key_micros],
          ['micro_type',COLS.micro_type],['micro_score',COLS.micro_score],['cog_benefits',COLS.cog_benefits],
          ['other_benefits',COLS.other_benefits],['diets_list',COLS.diets_list],
          ['serving_size',COLS.serving_size],['mech_fn',COLS.mech_fn],['sources_details',COLS.sources_details]
        ];
        for (const [k,aliases] of groups){
          if (dst[k]==null){
            const v = pick(r, aliases);
            if (v!=null && String(v).trim()!=='') dst[k]=v;
          }
        }
      }
    }

    // ---------- Ingredient list detection (robust) ----------
    function findIngredientBlocks(root){
      const out = [];
      // Strategy A: explicit heading near a UL/OL
      const nodes = root.querySelectorAll('h1,h2,h3,h4,strong,b,div,span,p');
      nodes.forEach(h=>{
        const txt = (h.textContent||'').trim();
        if (!HEADING_REGEX.test(txt)) return;
        // search next few siblings for a list
        let el = h.nextElementSibling, hops=0, found=null;
        while (el && hops<8){
          if (el.tagName==='UL' || el.tagName==='OL'){ found=el; break; }
          // some GPT outputs wrap lists inside a div
          const inner = el.querySelector && el.querySelector('ul,ol');
          if (inner){ found = inner; break; }
          if (/^H[1-6]$/.test(el.tagName)) break;
          el = el.nextElementSibling; hops++;
        }
        if (found && found.children.length>0) out.push({heading:h, list:found});
      });

      // Strategy B: any UL/OL that has a preceding sibling in the last few elements containing “Ingredients”
      const lists = root.querySelectorAll('ul,ol');
      lists.forEach(list=>{
        if ([...out].some(o=>o.list===list)) return;
        if (!list.children.length) return;
        let prev=list.previousElementSibling, steps=0, ok=false;
        while(prev && steps<5){
          const t=(prev.textContent||'').trim();
          if (/ingredients\s*:?/i.test(t)){ ok=true; break; }
          if (/^H[1-6]$/.test(prev.tagName)) break;
          prev=prev.previousElementSibling; steps++;
        }
        if (ok) out.push({heading:prev||list, list});
      });

      return out;
    }

    function parseIngredients(list){
      const out=[];
      list.querySelectorAll('li').forEach(li=>{
        const raw=(li.textContent||'').trim();
        if(!raw) return;
        const m = raw.match(/^([\d\/\.\,\s\-]+)?\s*([a-zA-Zµ]+)?\s*(.*)$/);
        let qty=null,unit=null,namePart=raw;
        if(m){ qty = fracToFloat(m[1]); unit=m[2]?m[2].toLowerCase():null; namePart=m[3]||raw; }
        const name = canonical(namePart);
        if (name) out.push({ raw,name,qty,unit });
      });
      return out;
    }

    function fracToFloat(s){
      if(!s) return null;
      const parts = String(s).trim().split(/\s+/); let total=0;
      for (const p of parts){
        if (p.includes('/')){ const [a,b]=p.split('/').map(Number); if(Number.isFinite(a)&&Number.isFinite(b)&&b!==0) total+=a/b; }
        else { const v=parseFloat(p); if(Number.isFinite(v)) total+=v; }
      }
      return Number.isFinite(total)&&total>0 ? total : null;
    }

    function attachDB(it){
      const key = toKey(it.name);
      const rec = STATE.db[key] || null;
      const display = rec? (rec._name || it.raw || it.name) : (it.raw || it.name);
      return { ...it, rec, display };
    }

    // ---------- Builders ----------
    function buildAllTables(ingredients){
      const rows = ingredients.map(attachDB).sort((a,b)=>a.display.localeCompare(b.display));
      const t1 = buildNutritionTable(rows);
      const t2 = buildCogTable(rows);
      const t3 = buildDietTable(rows);
      const t4 = buildMicrobiomeTable(rows);
      const t5 = buildMicronutrientBenefitsTable(rows);
      return `<div class="bp5stack">${t1}${t2}${t3}${t4}${t5}</div>`;
    }

    function buildNutritionTable(rows){
      let totCal=0, totProt=0, totFib=0, totGL=0;
      const body = rows.map(r=>{
        const d=r.rec||{};
        const cal=num(d.calories); if(cal!=null) totCal+=cal;
        const pr=num(d.protein_g); if(pr!=null) totProt+=pr;
        const fi=num(d.fiber_g);   if(fi!=null) totFib+=fi;
        const gi=num(d.gi);
        const gl=num(d.gl);        if(gl!=null) totGL+=gl;
        const dii = (d.dii!=null && String(d.dii).trim()!=='') ? d.dii : 'N/A';
        const keyMicros = d.key_micros ?? 'N/A';
        const mType = d.micro_type ?? 'N/A';
        const mScore = d.micro_score ?? 'N/A';
        return `<tr>
          <td>${escapeHTML(r.display)}</td>
          <td>${fmt(cal)}</td>
          <td>${fmt(pr)}</td>
          <td>${fmt(fi)}</td>
          <td>${gi==null?'N/A':fmt(gi)}</td>
          <td>${gl==null?'N/A':fmt(gl)}</td>
          <td>${escapeHTML(String(dii))}</td>
          <td>${escapeHTML(String(keyMicros))}</td>
          <td>${escapeHTML(String(mType))}</td>
          <td>${escapeHTML(String(mScore))}</td>
        </tr>`;
      }).join('');
      const totals = `<tr class="bp-total">
        <td>Totals</td><td>${fmt(totCal)}</td><td>${fmt(totProt)}</td><td>${fmt(totFib)}</td><td>—</td><td>${fmt(totGL)}</td><td>—</td><td>—</td><td>—</td><td>—</td>
      </tr>`;
      return `
        <h3>1. Nutrition Table</h3>
        <table class="bp-table">
          <thead>
            <tr>
              <th>Ingredient</th>
              <th>Calories</th>
              <th>Protein (g)</th>
              <th>Fiber (g)</th>
              <th>GI</th>
              <th>GL</th>
              <th>Anti-Inflammatory/<wbr>DII Score<br>(lower is better)</th>
              <th>Key Micronutrients</th>
              <th>Microbiome Prebiotic or Probiotic or Postbiotic</th>
              <th>Microbiome Benefit Score</th>
            </tr>
          </thead>
          <tbody>${body}${totals}</tbody>
        </table>
        <div class="bp-footnote">Totals sum Calories, Protein, Fiber, and GL. GI and DII are not additive (shown as “—”). “N/A” appears when data are not available.</div>
      `;
    }

    function buildCogTable(rows){
      const body = rows.map(r=>{
        const d=r.rec||{};
        return `<tr><td>${escapeHTML(r.display)}</td><td>${escapeHTML(d.cog_benefits ?? 'N/A')}</td><td>${escapeHTML(d.other_benefits ?? 'N/A')}</td></tr>`;
      }).join('');
      return `
        <h3>2. Cognitive &amp; Other Health Benefits Table</h3>
        <table class="bp-table">
          <thead><tr><th>Ingredient</th><th>Cognitive Benefits &amp; Mechanisms</th><th>Other Health Benefits</th></tr></thead>
          <tbody>${body}</tbody>
        </table>
      `;
    }

    function buildDietTable(rows){
      const body = rows.map(r=>{
        const d=r.rec||{};
        let diets = d.diets_list;
        if (!diets) diets = deriveDietList(d._rows || []);
        return `<tr><td>${escapeHTML(r.display)}</td><td>${escapeHTML(diets ? String(diets) : 'N/A')}</td></tr>`;
      }).join('');
      return `
        <h3>3. Diet Compatibility Table</h3>
        <table class="bp-table">
          <thead><tr><th>Ingredient</th><th>Compatible Diets</th></tr></thead>
          <tbody>${body}</tbody>
        </table>
      `;
    }

    function deriveDietList(rows){
      if(!rows.length) return null;
      const yes=new Set();
      for (const r of rows){
        for (const d of POSSIBLE_DIETS){
          if (d in r){
            const v = String(r[d]).toLowerCase();
            if (['1','y','yes','true','✓','x'].includes(v)) yes.add(d);
          }
        }
      }
      return yes.size ? Array.from(yes).sort().join(', ') : null;
    }

    function buildMicrobiomeTable(rows){
      const body = rows.map(r=>{
        const d=r.rec||{};
        return `<tr><td>${escapeHTML(r.display)}</td><td>${escapeHTML(d.micro_type ?? 'N/A')}</td><td>${escapeHTML(d.micro_score ?? 'N/A')}</td></tr>`;
      }).join('');
      return `
        <h3>4. Microbiome Benefit Table</h3>
        <table class="bp-table">
          <thead><tr><th>Ingredient</th><th>Microbiome Prebiotic or Probiotic or Postbiotic</th><th>Microbiome Benefit Score</th></tr></thead>
          <tbody>${body}</tbody>
        </table>
      `;
    }

    function buildMicronutrientBenefitsTable(rows){
      const body = rows.map(r=>{
        const d=r.rec||{};
        const serving = d.serving_size ?? 'N/A';
        const keyN = d.key_micros ?? 'N/A';
        const mech = d.mech_fn ?? 'N/A';
        const srcs = d.sources_details ?? 'N/A';
        const pct = estimatePercentRDA(d); // best-effort; “N/A” if not computable
        return `<tr><td>${escapeHTML(r.display)}</td><td>${escapeHTML(serving)}</td><td>${escapeHTML(keyN)}</td><td>${escapeHTML(mech)}</td><td>${escapeHTML(srcs)}</td><td>${escapeHTML(pct ?? 'N/A')}</td></tr>`;
      }).join('');
      return `
        <h3>5. Micronutrient Benefits Table</h3>
        <table class="bp-table">
          <thead>
            <tr>
              <th>Ingredient</th>
              <th>Serving Size</th>
              <th>Key Nutrients/Bioactives</th>
              <th>Mechanism/Function</th>
              <th>Notable Sources/Details</th>
              <th>% Recommended Daily Amount</th>
            </tr>
          </thead>
          <tbody>${body}</tbody>
        </table>
        <div class="bp-footnote">%RDA appears only when present/derivable in your CSVs; otherwise “N/A”.</div>
      `;
    }

    function estimatePercentRDA(rec){
      try{
        const rows = rec._rows || [];
        for (const row of rows){
          for (const k in row){
            const key = k.toLowerCase();
            if (/%\s*rda/.test(key) || /rda_%/.test(key) || /percent[_\s]?rda/.test(key)){
              const v = num(row[k]); if (v!=null) return fmt(v);
            }
          }
        }
        return null;
      } catch { return null; }
    }

    // ---------- Injection + observation ----------
    function injectForRoot(root){
      const blocks = findIngredientBlocks(root);
      blocks.forEach(({heading,list})=>{
        if (!list || !list.children || !list.children.length) return;
        if (list.nextElementSibling && list.nextElementSibling.classList && list.nextElementSibling.classList.contains('bp5stack')) return;

        const items = parseIngredients(list);
        if (!items.length) return;
        const html = buildAllTables(items);
        const wrap = document.createElement('div');
        wrap.innerHTML = html;
        list.insertAdjacentElement('afterend', wrap.firstElementChild);
        STATE.tablesMade++;
      });
    }

    function startObserver(){
      const mo = new MutationObserver(muts=>{
        muts.forEach(m=>{
          (m.addedNodes||[]).forEach(n=>{
            if (n.nodeType===1) injectForRoot(n);
          });
        });
      });
      mo.observe(document.body,{childList:true,subtree:true});

      // initial scan + a few retries in case content streams in slowly
      injectForRoot(document);
      let tries=0;
      const timer = setInterval(()=>{
        injectForRoot(document);
        if (++tries>5) clearInterval(timer);
      }, 800);
    }

    // ---------- Boot ----------
    document.addEventListener('DOMContentLoaded', async ()=>{
      await loadAllCSVs();
      if (STATE.csvRows===0){
        showDiag('err','CSV data not found','I looked for your 10 files in /data/ and data/. Ensure they’re uploaded to the deployed site in a “data” folder.');
      }
      startObserver();

      // After a few seconds, if no tables were made, give a gentle hint.
      setTimeout(()=>{
        if (STATE.tablesMade===0){
          showDiag('warn','No Ingredients detected','I didn’t find an “Ingredients” list. Make sure your recipe shows a heading “Ingredients” (with a list beneath).');
        }
      }, 5000);
    });
  })();
  </script>
</body>
</html>
