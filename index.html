<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Brain Healthy Meal Generator — Standalone</title>
  <style>
    :root{ --bg:#f7f8fb; --fg:#111; --muted:#667085; --card:#fff; --line:#e5e7eb; --accent:#0a60ff; }
    *{box-sizing:border-box}
    body{font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;margin:0;background:var(--bg);color:var(--fg)}
    main{max-width:980px;margin:28px auto;padding:0 16px}
    h1{margin:0 0 8px}
    h2{margin:0 0 8px}
    .subtitle{color:#475467;margin:0 0 12px}
    .card{background:var(--card);border:1px solid var(--line);border-radius:16px;padding:18px;box-shadow:0 4px 14px rgba(0,0,0,.04);margin:18px 0}
    textarea{width:100%;padding:12px;border:1px solid #d0d5dd;border-radius:12px}
    .row{display:flex;align-items:center;gap:10px;margin:10px 0}
    input[type="number"]{width:120px;padding:10px;border:1px solid #d0d5dd;border-radius:12px}
    button{padding:10px 14px;border:1px solid var(--accent);background:var(--accent);color:#fff;border-radius:12px;cursor:pointer}
    button.ghost{border-color:#d0d5dd;background:#fff;color:#111}
    button:disabled{opacity:.6;cursor:not-allowed}
    .btn-row{display:flex;gap:10px;flex-wrap:wrap}
    /* HIGH CONTRAST recipe/coaching output */
    pre{white-space:pre-wrap;background:#ffffff;color:#111111;padding:14px;border-radius:12px;min-height:48px;margin-top:12px;border:1px solid #e5e7eb}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:16px}
    @media (max-width:860px){.grid{grid-template-columns:1fr}}
    .accordion{border:1px dashed #d6d6d6;border-radius:12px;margin:10px 0;overflow:hidden;background:#fff}
    .acc-header{display:flex;justify-content:space-between;align-items:center;padding:12px 14px;background:#f9fafb;cursor:pointer}
    .acc-header h4{margin:0;font-size:15px}
    .acc-content{display:none;padding:12px 14px;background:#fff}
    .acc-content.open{display:block}
    .checks{display:flex;flex-wrap:wrap;gap:8px}
    .checks label{display:inline-flex;align-items:center;gap:8px;padding:6px 10px;border:1px solid #e5e7eb;border-radius:10px}
    .muted{color:#667085;font-size:13px;margin:0 0 6px}
    .status{font-size:12px;color:#475467;margin-top:8px}
    .error{color:#b42318;background:#fef3f2;border:1px solid #fed7d7;padding:8px;border-radius:8px;margin-top:8px}
  </style>
</head>
<body>
  <main>
    <h1>Brain Healthy Meal Generator</h1>
    <p class="subtitle">Choose ingredients, set goals, or type a custom request. Recipes and coaching appear inline—no new tab.</p>

    <!-- A) Custom Request -->
    <section class="card">
      <h2>Custom Request</h2>
      <p>Example: “Make 3 dinners with salmon and legumes, dairy-free, low sodium.” Leave the number blank to default to 3–5 recipes.</p>
      <textarea id="custom-input" rows="4" placeholder="Describe the meal(s) you want..."></textarea>
      <div class="row">
        <label for="num-recipes">Number of recipes (optional):</label>
        <input id="num-recipes" type="number" min="1" max="10" placeholder="3–5" />
      </div>
      <div class="btn-row">
        <button onclick="generateFromCustom()">Generate Recipes</button>
        <button class="ghost" type="button" onclick="clearCustomSection()">Clear Custom</button>
      </div>
      <pre id="custom-output"></pre>
    </section>

    <!-- B) Build From Ingredients -->
    <section class="card">
      <h2>Build From Ingredients</h2>
      <p>Select ingredients to include and categories to exclude. Your selections preview below.</p>

      <div class="grid">
        <div>
          <h3>Include Ingredients</h3>
          <div id="include-root"></div>
        </div>

        <div>
          <div class="accordion" id="exclude-accordion">
            <div class="acc-header" role="button" tabindex="0" aria-expanded="false" onclick="toggleAccordion(this)">
              <h4>Exclude Categories</h4>
              <span class="muted">Click to expand</span>
            </div>
            <div class="acc-content">
              <p class="muted">Check entire categories to exclude them (e.g., “Dairy”).</p>
              <div class="checks" id="exc-categories"></div>
            </div>
          </div>

          <div class="accordion" id="goals-accordion">
            <div class="acc-header" role="button" tabindex="0" aria-expanded="false" onclick="toggleAccordion(this)">
              <h4>Nutrition Goals</h4>
              <span class="muted">Click to expand</span>
            </div>
            <div class="acc-content">
              <p class="muted">Select one or more goals to tailor coaching suggestions.</p>
              <div class="checks" id="goals"></div>
            </div>
          </div>
        </div>
      </div>

      <h3>Preview</h3>
      <pre id="form-preview">No selections yet.</pre>

      <div class="btn-row">
        <button onclick="generateFromSelections()">Generate Recipes from Selections</button>
        <button class="ghost" type="button" onclick="clearFormSelections()">Clear Form</button>
      </div>

      <div id="status" class="status"></div>
    </section>

    <!-- OUTPUTS -->
    <section class="card">
      <h2>Results</h2>
      <div id="outputs"></div>
    </section>
  </main>

  <!-- CSV parser -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <script>
    // =========================
    // CONFIG
    // =========================
    const CFG = {
      generateEndpoint: '/.netlify/functions/generate',
      datasets: {
        // Primary expected filenames (must exist in /data)
        categories:          'data/categories.csv',
        diet_tool:           'data/diet_tool.csv',
        fiber:               'data/fiber.csv',
        gi_gl:               'data/gi_gl.csv',
        main:                'data/main.csv',
        microbiome:          'data/microbiome.csv', // If you keep Microbiome_Scored.csv, we will auto-detect below
        micronutrients_list: 'data/micronutrients_list.csv', // fallback loader will try common misspellings
        micronutrients_food: 'data/micronutrients_food.csv',
        moder:               'data/moder.csv',
        protein:             'data/protein.csv'
      }
    };

    // =========================
    // INGREDIENT CATEGORIES (static UI source)
    // =========================
    const STARTER_INGREDIENTS = {
      "Vegetables": ["GPT CHOOSES VEGETABLES","Arugula","Collard Greens","Kale","Mustard Greens","Romaine","Spinach","Swiss Chard","Broccoli","Brussel Sprouts","Cabbage","Cauliflower","Bell Peppers","Chili Peppers","Eggplant","Tomatoes","Beets","Carrots","Sweet Potatoes","Artichokes","Asparagus","Celery","Cucumber","Onions","Zucchini","Mushrooms","Cornmeal (whole grain)","Blue Corn","Sweet Corn","Grits (whole grain, cooked)","Heirloom Corn","Hominy Corn","Purple Corn","Polenta (cooked)"],
      "Legumes": ["GPT CHOOSES LEGUMES","Chickpeas","Edamame","Green Peas","Lentils","Lupins","Miso","Natto","Peanuts","Soybeans","Split Peas","Tempeh","Tofu","Adzuki Beans","Black Beans","Kidney Beans","Mung Beans","Navy Beans","Pinto beans"],
      "Fruit": ["GPT CHOOSES FRUIT","Apples","Avocados","Blackberries","Blueberries","Cranberries","Golgi Berries","Gooseberries","Grapes","Kiwis","Mulberries","Olives","Passion Fruit","Raspberries","Strawberries","Orange","Grapefruit","Lemon","Cherries","Watermelon","Black currants (Dried)","Bilberries (Dried)","Cranberries (Dried)","Prunes","Dates","Figs","Raisins","Gooseberries (Dried)","Mulberries (Dried)"],
      "Fish": ["GPT CHOOSES FISH","Anchovies","Herring","Mackerel","Salmon","Sardines","Flounder","Sea Bass","Sturgeon","Trout","Yellow Catfish"],
      "Whole Grains": ["GPT CHOOSES WHOLE GRAINS","Amaranth","Barley","Brown Rice","Farro","Millet","Oats/Oat Groats/Steel Cut/Rolled","Quinoa","Whole Grain (Bread)","Whole Wheat"],
      "Nuts/Seeds": ["GPT CHOOSES NUTS OR SEEDS","Almonds","Almond Milk","Brazil Nuts","Cashews","Hazelnuts","Macadamia Nuts","Pecans","Pistachios","Walnuts","Chia Seeds","Flaxseeds","Pumpkin Seeds","Sesame Seeds","Sunflower Seeds"],
      "Meat": ["GPT CHOOSES THE MEAT","Chicken Breast (skinless)","Turkey","Lamb","Pork Liver"],
      "Pasta": ["GPT CHOOSES PASTA","Beet Pasta","Brown Rice Pasta","Buckwheat (Soba) Noodles","Chickpea Pasta","Lentil Pasta","Quinoa Pasta","Semolina Pasta","Sourdough Pasta","Spelt Pasta","Spinach Pasta","Whole Grain Pasta (non-wheat options)","Whole Wheat Pasta"],
      "Dairy": ["GPT CHOOSES DAIRY","Asiago Cheese","Brie Cheese","Blue Cheese","Camembert Cheese","Cheddar Cheese","Edam Cheese","Gouda Cheese","Gruyère Cheese","Parmesan Cheese","Provolone Cheese","Romano Cheese","Swiss Cheese","Cottage Cheese","Feta Cheese","Limburger Cheese","Mozzarella Cheese (if fermented)","Tilsit Cheese","Yogurt (Fermented)","Low-fat Milk","Kefir"],
      "Oils": ["GPT CHOOSES THE OIL","Avocado Oil (Cold-pressed, expeller-pressed)","Olive Oil (Extra Virgin -Cold-pressed)","Algae Oil","Cod Liver Oil","Krill Oil","Seaweed OIl","Chia Seed Oil","Flaxseed Oil","Hemp Seed Oil","Camellia Oil","Canola/Rapeseed Oil","Peony Oil","Pomegranate Seed Oiil","Safflower Oil","Sesame Oil","Soybean Oil","Sunflower Oil","Walnut Oil"],
      "Fermented Foods": ["Apple Cider Vinegar","Balsamic Vinegar","Kefir","Kimchi","Kombucha (Unsweetened)","Sauerkraut","Yogurt (Fermented)"],
      "Other Ingredients": ["GPT CHOOES OTHER (EGGS, COFFEE, TEA, HONEY, OTHERS)","Cacao","Capers","Coffee","Eggs","Green Tea","Honey","Kombucha (Unsweetened)","Seaweed","Soy Milk"]
    };
    const EXCLUDE_CATEGORIES = Object.keys(STARTER_INGREDIENTS);
    const GOALS = [
      "General Cognitive Health",
      "Weight Loss / Metabolic Health",
      "Blood Sugar Control (Low GI/GL)",
      "Cardiovascular Support (Low Sodium / Healthy Fats)",
      "Sleep Support",
      "Anti-inflammatory Focus (Lower DII)",
      "Microbiome Support (Pre/Pro/Post-biotic)"
    ];

    // =========================
    // HELPERS
    // =========================
    function el(tag, attrs={}, ...children){
      const node = document.createElement(tag);
      Object.entries(attrs).forEach(([k,v])=>{
        if(k==='class') node.className = v;
        else if(k==='for') node.setAttribute('for', v);
        else if(k==='html') node.innerHTML = v;
        else node.setAttribute(k,v);
      });
      children.forEach(c => node.append(c));
      return node;
    }
    function slugify(s){ return String(s||'').toLowerCase().replace(/\s+/g,'-').replace(/[^a-z0-9\-]/g,''); }
    function toggleAccordion(header){
      const acc = header.parentElement;
      const content = acc.querySelector('.acc-content');
      const open = content.classList.toggle('open');
      header.setAttribute('aria-expanded', open ? 'true' : 'false');
    }
    function setStatus(msg){ const s=document.getElementById('status'); if(s) s.textContent = msg; }

    // Checkbox renderer
    function renderIncludeAccordions(){
      const root = document.getElementById('include-root');
      root.innerHTML = '';
      Object.entries(STARTER_INGREDIENTS).forEach(([cat, items])=>{
        const catSlug = slugify(cat);
        const acc = el('div', { class:'accordion' });
        const header = el('div', { class:'acc-header', role:'button', tabindex:'0', 'aria-expanded':'false', onclick:'toggleAccordion(this)' },
          el('h4', {}, cat),
          el('span', { class:'muted' }, 'Click to expand')
        );
        const content = el('div', { class:'acc-content' });
        const list = el('div', { class:'checks' });
        items.forEach(val=>{
          const id = `inc-${catSlug}-${slugify(val)}`;
          const input = el('input', { type:'checkbox', id, value:val, 'data-cat':catSlug });
          const label = el('label', { for:id }, input, val);
          list.appendChild(label);
        });
        content.appendChild(list);
        acc.appendChild(header); acc.appendChild(content);
        root.appendChild(acc);
      });
    }

    function renderChecks(containerId, items){
      const root = document.getElementById(containerId); root.innerHTML = '';
      items.forEach(v=>{
        const id = `${containerId}-${slugify(v)}`;
        const input = el('input', { type:'checkbox', id, value:v });
        const label = el('label', { for:id }, input, v);
        root.appendChild(label);
      });
    }

    function getSelectedByCat(){
      const inputs = document.querySelectorAll('input[type=checkbox][data-cat]');
      const out = {};
      inputs.forEach(i=>{
        const cat = i.getAttribute('data-cat');
        if (i.checked){ (out[cat] ||= []).push(i.value); }
      });
      return out;
    }
    function getSelected(containerId){
      const root = document.getElementById(containerId);
      const inputs = root ? root.querySelectorAll('input[type=checkbox]:checked') : [];
      return Array.from(inputs).map(i=>i.value);
    }

    function collectForm(){
      const selections = {};
      Object.keys(STARTER_INGREDIENTS).forEach(cat=>{
        const slug = slugify(cat);
        selections[cat] = getSelectedByCat()[slug] || [];
      });
      const exclusions = getSelected('exc-categories');
      const goals = getSelected('goals');
      return { selections, exclusions, goals };
    }
    function buildPreviewText(data){
      const parts = [];
      for (const [cat, list] of Object.entries(data.selections)) {
        if (list && list.length) parts.push(`${cat}: ${list.join(', ')}`);
      }
      if (data.exclusions?.length) parts.push(`Exclude categories: ${data.exclusions.join(', ')}`);
      if (data.goals?.length) parts.push(`Goals: ${data.goals.join(', ')}`);
      return parts.length ? parts.join('\n') : 'No selections yet.';
    }

    // =========================
    // OPENAI VIA NETLIFY FUNCTION (JSON-STRICT)
    // =========================
    const JSON_SCHEMA_PROMPT = `You are BrainPreserve's recipe engine. Return STRICT JSON only, no markdown, no preamble.
Rules:
- Always produce the exact schema below.
- Ingredient amounts must include both a human-readable 'amount' string and a best-effort numeric 'grams' field (number). If grams cannot be estimated, set grams to null.
- Never vary the schema or keys. Never ask questions.
- Default to 3–5 recipes when a number is not provided.

Schema:
{
  "recipes": [
    {
      "title": string,
      "servings": number,
      "ingredients": [ { "name": string, "amount": string, "grams": number|null } ],
      "instructions": [ string ]
    }
  ]
}`;

    async function callOpenAI(messages){
      const resp = await fetch(CFG.generateEndpoint, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ messages, temperature: 0.3, max_tokens: 1400, model: 'gpt-4o-mini' })
      });
      const data = await resp.json();
      if (!resp.ok) throw new Error(data?.error || ('HTTP '+resp.status));
      return data?.content || '';
    }

    // =========================
    // CSV LOADING & NORMALIZATION
    // =========================
    const DATA = { loaded:false, byKey:Object.create(null), exists:{} };
    function norm(s){ return String(s||'').trim().toLowerCase(); }
    function baseName(path){ return (path||'').split('/').pop(); }

    // Try alternate filenames automatically
    const ALT_FILES = {
      microbiome: ['data/Microbiome_Scored.csv','data/microbiome_scored.csv'],
      micronutrients_list: ['data/micronutients_list.csv','data/Micronutrients_List.csv'],
    };

    function first(obj, names){ for (const n of names){ if (n in obj && obj[n]!=null && obj[n]!=='' ) return obj[n]; } }
    function pickKey(row){ return first(row,['Ingredient','Food','Item','Name']); }

    // Column maps per dataset
    const FILE_MAP = {
      main: {
        maps:{
          Calories:['Calories','kcal'],
          Protein_g:['Protein (g)','Protein_g','Protein'],
          Fiber_g:['Fiber (g)','Fiber_g','Fiber'],
          GI:['GI','Glycemic Index'], GL:['GL','Glycemic Load'],
          Micronutrients:['Key Micronutrients','Micronutrients'],
          DietTags:['Diet Tags','Tags','Compatible Diets'],
          CognitiveBenefits:['Cognitive Benefits & Mechanisms','Cognitive Benefits'],
          OtherBenefits:['Other Health Benefits','Other Benefits']
        }
      },
      protein:{ maps:{ Protein_g:['Protein (g)','Protein_g','Protein'] }},
      fiber:{ maps:{ Fiber_g:['Fiber (g)','Fiber_g','Fiber'] }},
      gi_gl:{ maps:{ GI:['GI','Glycemic Index'], GL:['GL','Glycemic Load'] }},
      microbiome:{ maps:{
        MicrobiomeType:['Microbiome Prebiotic or Probiotic or Postbiotic','MicrobiomeType','Type'],
        MicrobiomeScore:['Microbiome Benefit Score','MicrobiomeScore','Score']
      }},
      micronutrients_food:{ maps:{
        Micronutrients:['Key Micronutrients','Micronutrients','Top Micronutrients'],
        ServingSizeHint:['Serving Size','Serving','Typical Serving']
      }},
      categories:{ maps:{ DietTags:['Diet Tags','Tags','Category','Categories','Compatible Diets'] }},
      diet_tool:{ maps:{ DII:['DII Score','Anti-Inflammatory/DII Score (lower is better)','DII','anti_inflammatory_dii'] }},
      moder:{ maps:{ DII:['DII Score','Anti-Inflammatory/DII Score (lower is better)','DII','anti_inflammatory_dii'] }},
      micronutrients_list:{ maps:{
        RDA:['RDA','Recommended Daily Amount','Daily Value %','DV','% RDA'],
        MechanismFunction:['Mechanism/Function','Function'],
        SourcesDetails:['Notable Sources/Details','Sources']
      }}
    };

    function applyMap(target, row, map){
      for (const [canon, options] of Object.entries(map||{})){
        const val = first(row, options);
        if (val!=null && val!=='') target[canon] = val;
      }
    }
    function mergeRow(target, row){
      if (!target.Ingredient) target.Ingredient = first(row, ['Ingredient','Food','Item','Name']);
      // Prefer explicit numeric values when present
      ['Calories','Protein_g','Fiber_g','GI','GL','DII'].forEach(k=>{
        if (row[k] != null && row[k] !== '') target[k] = row[k];
      });
      // Text blends
      ['Micronutrients','DietTags','CognitiveBenefits','OtherBenefits','MicrobiomeType','MechanismFunction','SourcesDetails','ServingSizeHint'].forEach(k=>{
        if (row[k] != null && row[k] !== '' && !target[k]) target[k] = row[k];
      });
      if (row.MicrobiomeScore != null && row.MicrobiomeScore !== '') target.MicrobiomeScore = row.MicrobiomeScore;
      if (row.RDA != null && row.RDA !== '') target.RDA = row.RDA; // may be nutrient-level; used if aligned
    }

    async function loadCSV(path){
      // Record existence
      DATA.exists[baseName(path)] = true;
      return new Promise((resolve,reject)=>{
        Papa.parse(path, { download:true, header:true, dynamicTyping:true, skipEmptyLines:true,
          complete:(res)=>resolve(res.data), error:(e)=>reject(e) });
      });
    }

    async function tryLoad(key, path){
      try { return await loadCSV(path); }
      catch(err){ return null; }
    }

    async function ensureDataLoaded(){
      if (DATA.loaded) return;
      // Detect alternates where helpful
      const resolved = { ...CFG.datasets };
      if (await tryLoad('microbiome', CFG.datasets.microbiome) === null){
        for (const alt of ALT_FILES.microbiome){
          const rows = await tryLoad('microbiome', alt);
          if (rows){ resolved.microbiome = alt; break; }
        }
      }
      // Micronutrients list common misspelling
      if (await tryLoad('micronutrients_list', CFG.datasets.micronutrients_list) === null){
        for (const alt of ALT_FILES.micronutrients_list){
          const rows = await tryLoad('micronutrients_list', alt);
          if (rows){ resolved.micronutrients_list = alt; break; }
        }
      }

      const order = ['main','protein','fiber','gi_gl','microbiome','micronutrients_food','categories','diet_tool','moder','micronutrients_list'];
      for (const key of order){
        const path = resolved[key];
        if (!path) continue;
        let rows = await tryLoad(key, path);
        if (!rows) continue;
        const m = FILE_MAP[key];
        for (const row of rows){
          const k = pickKey(row); if (!k) continue;
          const id = norm(k);
          const rec = (DATA.byKey[id] ||= {});
          mergeRow(rec, row);
          if (m) applyMap(rec, row, m.maps||{});
        }
      }
      DATA.loaded = true;
    }

    // Lookup helpers
    function normalizeName(name){
      let s = String(name||'').toLowerCase();
      s = s.replace(/\([^\)]*\)/g,''); // remove parentheticals
      s = s.replace(/[^a-z0-9\s]/g,' ').replace(/\s+/g,' ').trim();
      if (s.endsWith('es')) s = s.slice(0,-2); else if (s.endsWith('s')) s = s.slice(0,-1);
      return s;
    }
    function fuzzyLookup(name){
      const exact = DATA.byKey[norm(name)];
      if (exact) return exact;
      const n = normalizeName(name);
      // Try startswith/contains over keys
      const keys = Object.keys(DATA.byKey);
      let best = null;
      for (const k of keys){
        if (k === n || k.startsWith(n) || n.startsWith(k) || k.includes(n)) { best = DATA.byKey[k]; break; }
      }
      return best;
    }

    // =========================
    // MARKDOWN RENDERING
    // =========================
    function mdEscape(s){
      return String(s==null ? '' : s).replace(/\|/g,'\\|');
    }
    function mdTable(headers, rows){
      const head = `| ${headers.map(mdEscape).join(' | ')} |`;
      const sep  = `| ${headers.map(()=>'-').join(' | ')} |`;
      const body = rows.map(r=>`| ${r.map(v=>mdEscape(v)).join(' | ')} |`).join('\n');
      return `${head}\n${sep}\n${body}`;
    }

    function sumNums(arr){ return arr.reduce((a,b)=> a + (Number.isFinite(+b) ? (+b) : 0), 0); }

    function buildNutritionTable(ingredients){
      // ingredients: [{ name, grams, amount }]
      const rows = [];
      for (const ing of ingredients){
        const rec = fuzzyLookup(ing.name) || {};
        rows.push({
          Ingredient: ing.name,
          Calories: rec.Calories ?? 'N/A',
          Protein_g: rec.Protein_g ?? 'N/A',
          Fiber_g:   rec.Fiber_g ?? 'N/A',
          GI:        rec.GI ?? 'N/A',
          GL:        rec.GL ?? 'N/A',
          DII:       rec.DII ?? 'N/A',
          Micronutrients: rec.Micronutrients ?? 'N/A',
          MicrobiomeType: rec.MicrobiomeType ?? 'N/A',
          MicrobiomeScore: rec.MicrobiomeScore ?? 'N/A',
          DietTags: rec.DietTags ?? 'N/A'
        });
      }
      // sort by ingredient name
      rows.sort((a,b)=> String(a.Ingredient).localeCompare(String(b.Ingredient)) );
      // totals
      const totals = {
        Ingredient: 'Totals',
        Calories: sumNums(rows.map(r=>r.Calories)),
        Protein_g: sumNums(rows.map(r=>r.Protein_g)),
        Fiber_g:   sumNums(rows.map(r=>r.Fiber_g)),
        GI: 'N/A',
        GL: sumNums(rows.map(r=>r.GL)),
        DII: 'N/A',
        Micronutrients: '—',
        MicrobiomeType: '—',
        MicrobiomeScore: '—',
        DietTags: '—'
      };

      const headers = [
        'Ingredient','Calories','Protein (g)','Fiber (g)','GI','GL','Anti-Inflammatory/<wbr>DII Score<br>(lower is better)','Key Micronutrients','Microbiome Prebiotic or Probiotic or Postbiotic','Microbiome Benefit Score','Compatible Diets'
      ];
      const dataRows = rows.map(r=>[
        r.Ingredient, r.Calories, r.Protein_g, r.Fiber_g, r.GI, r.GL, r.DII, r.Micronutrients, r.MicrobiomeType, r.MicrobiomeScore, r.DietTags
      ]);
      dataRows.push([
        totals.Ingredient, totals.Calories, totals.Protein_g, totals.Fiber_g, totals.GI, totals.GL, totals.DII, totals.Micronutrients, totals.MicrobiomeType, totals.MicrobiomeScore, totals.DietTags
      ]);
      return mdTable(headers, dataRows);
    }

    function buildCognitiveBenefitsTable(ingredients){
      const headers = ['Ingredient','Cognitive Benefits & Mechanisms','Other Health Benefits'];
      const rows = ingredients.map(ing=>{
        const rec = fuzzyLookup(ing.name) || {};
        return [ing.name, rec.CognitiveBenefits ?? 'N/A', rec.OtherBenefits ?? 'N/A'];
      });
      rows.sort((a,b)=> String(a[0]).localeCompare(String(b[0])) );
      return mdTable(headers, rows);
    }

    function buildDietCompatibilityTable(ingredients){
      const headers = ['Ingredient','Compatible Diets'];
      const rows = ingredients.map(ing=>{
        const rec = fuzzyLookup(ing.name) || {};
        return [ing.name, rec.DietTags ?? 'N/A'];
      });
      rows.sort((a,b)=> String(a[0]).localeCompare(String(b[0])) );
      return mdTable(headers, rows);
    }

    function buildMicrobiomeBenefitTable(ingredients){
      const headers = ['Ingredient','Microbiome Prebiotic or Probiotic or Postbiotic','Microbiome Benefit Score'];
      const rows = ingredients.map(ing=>{
        const rec = fuzzyLookup(ing.name) || {};
        return [ing.name, rec.MicrobiomeType ?? 'N/A', rec.MicrobiomeScore ?? 'N/A'];
      });
      rows.sort((a,b)=> String(a[0]).localeCompare(String(b[0])) );
      return mdTable(headers, rows);
    }

    function buildMicronutrientBenefitsTable(ingredients){
      const headers = ['Ingredient','Serving Size','Key Nutrients/Bioactives','Mechanism/Function','Notable Sources/Details','% Recommended Daily Amount'];
      const rows = ingredients.map(ing=>{
        const rec = fuzzyLookup(ing.name) || {};
        const serving = ing.amount || rec.ServingSizeHint || 'N/A';
        // %RDA: requires nutrient-specific values; if absent, N/A
        const pct = 'N/A';
        return [ing.name, serving, (rec.Micronutrients ?? 'N/A'), (rec.MechanismFunction ?? 'N/A'), (rec.SourcesDetails ?? 'N/A'), pct];
      });
      rows.sort((a,b)=> String(a[0]).localeCompare(String(b[0])) );
      return mdTable(headers, rows);
    }

    function renderRecipeWithTables(recipe){
      const wrap = document.createElement('div');
      const h = document.createElement('h3'); h.textContent = recipe.title; wrap.appendChild(h);

      // Show recipe body (markdown-like as plain text for copyability)
      const recipeMd = [
        `**Servings:** ${recipe.servings}`,
        '',
        '**Ingredients:**',
        ...recipe.ingredients.map(i=>`- ${i.amount} ${i.name}`),
        '',
        '**Instructions:**',
        ...recipe.instructions.map((s,idx)=>`${idx+1}. ${s}`)
      ].join('\n');
      const preRecipe = document.createElement('pre');
      preRecipe.textContent = recipeMd;
      wrap.appendChild(preRecipe);

      // Build the five mandated tables (markdown)
      const tables = [
        { title: '1. Nutrition Table', md: buildNutritionTable(recipe.ingredients) },
        { title: '2. Cognitive & Other Health Benefits Table', md: buildCognitiveBenefitsTable(recipe.ingredients) },
        { title: '3. Diet Compatibility Table', md: buildDietCompatibilityTable(recipe.ingredients) },
        { title: '4. Microbiome Benefit Table', md: buildMicrobiomeBenefitTable(recipe.ingredients) },
        { title: '5. Micronutrient Benefits Table', md: buildMicronutrientBenefitsTable(recipe.ingredients) }
      ];

      for (const t of tables){
        const h4 = document.createElement('h4'); h4.textContent = t.title; wrap.appendChild(h4);
        const pre = document.createElement('pre'); pre.textContent = t.md; wrap.appendChild(pre);
      }

      return wrap;
    }

    // =========================
    // GENERATION HANDLERS
    // =========================
    async function ensureReady(){ await ensureDataLoaded(); }

    async function generateFromCustom(){
      setStatus('');
      const out = document.getElementById('custom-output');
      const custom = document.getElementById('custom-input').value.trim();
      const num = parseInt(document.getElementById('num-recipes').value, 10);
      const count = Number.isFinite(num) ? num : undefined;

      const sys = JSON_SCHEMA_PROMPT;
      const user = `${count ? `Generate ${count} recipes.` : 'Generate 3–5 recipes.'}\nRequest: ${custom || 'Chef’s choice within brain-healthy constraints.'}\nConstraints: Minimize ultra-processed foods and added sugars; reasonable sodium; prefer MIND/Mediterranean-aligned choices.`;

      out.textContent = 'Generating...';
      try{
        const text = await callOpenAI([{ role:'system', content: sys }, { role:'user', content: user }]);
        const json = parseJSONSafe(text);
        if (!json?.recipes?.length) throw new Error('Model returned no recipes or invalid JSON.');
        await ensureReady();
        const outputs = document.getElementById('outputs'); outputs.innerHTML = '';
        json.recipes.forEach(r => outputs.appendChild(renderRecipeWithTables(r)));
        out.textContent = '';
      }catch(err){ out.textContent = 'Error: ' + err.message; }
    }

    function clearCustomSection(){
      document.getElementById('custom-input').value = '';
      document.getElementById('num-recipes').value = '';
      document.getElementById('custom-output').textContent = '';
    }

    function clearFormSelections(){
      document.querySelectorAll('.checks input[type=checkbox]').forEach(i => { i.checked = false; });
      document.getElementById('form-preview').textContent = 'No selections yet.';
      const outputs = document.getElementById('outputs'); outputs.innerHTML = '';
      setStatus('');
    }

    async function generateFromSelections(){
      setStatus('Working…');
      const form = collectForm();
      document.getElementById('form-preview').textContent = buildPreviewText(form);

      try {
        const selLines = Object.entries(form.selections)
          .filter(([, list]) => list && list.length)
          .map(([k, list]) => `${k}: ${list.join(', ')}`)
          .join('\n');
        const exc = form.exclusions?.length ? `Exclude categories: ${form.exclusions.join(', ')}` : '';
        const goals = form.goals?.length ? `Goals: ${form.goals.join(', ')}` : '';

        const sys = JSON_SCHEMA_PROMPT;
        const user = `Selections:\n${selLines || '(none)'}\n${exc}\n${goals}\nConstraints: Respect exclusions strictly. Use included ingredients prominently. Keep to brain-healthy principles (MIND/Mediterranean, low sodium, minimal UPFs).`;

        const text = await callOpenAI([{ role:'system', content: sys }, { role:'user', content: user }]);
        const json = parseJSONSafe(text);
        if (!json?.recipes?.length) throw new Error('Model returned no recipes or invalid JSON.');

        await ensureReady();
        const outputs = document.getElementById('outputs'); outputs.innerHTML = '';
        json.recipes.forEach(r => outputs.appendChild(renderRecipeWithTables(r)));
        setStatus('Done.');
      } catch(err){
        const outputs = document.getElementById('outputs');
        outputs.innerHTML = '';
        const errBox = el('div',{class:'error'}, 'Error during generation: ', String(err?.message || err));
        outputs.appendChild(errBox);
        console.error(err);
        setStatus('Error.');
      }
    }

    function parseJSONSafe(text){
      if (!text) return null;
      // Remove markdown fences if present
      const cleaned = String(text).replace(/^```[a-zA-Z]*\n?|```$/g, '').trim();
      try{ return JSON.parse(cleaned); }catch(e){
        // Try to extract first JSON object/array
        const m = cleaned.match(/\{[\s\S]*\}|\[[\s\S]*\]/);
        if (m){ try{ return JSON.parse(m[0]); }catch(_){} }
        return null;
      }
    }

    // =========================
    // INIT UI
    // =========================
    (function init(){
      renderIncludeAccordions();
      renderChecks('exc-categories', EXCLUDE_CATEGORIES);
      renderChecks('goals', GOALS);

      document.body.addEventListener('change', (e)=>{
        if(e.target.closest('.checks')){
          const form = collectForm();
          document.getElementById('form-preview').textContent = buildPreviewText(form);
        }
      });
    })();

    // Export handlers
    window.generateFromSelections = generateFromSelections;
    window.generateFromCustom     = generateFromCustom;
    window.clearFormSelections    = clearFormSelections;
    window.clearCustomSection     = clearCustomSection;
    window.toggleAccordion        = toggleAccordion;
  </script>
</body>
</html>
