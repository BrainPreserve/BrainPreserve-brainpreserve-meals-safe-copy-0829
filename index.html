<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Brain Healthy Nutrition Tables — Normalized CSV Loader</title>
  <style>
    :root{ --bg:#f7f8fb; --fg:#111; --muted:#667085; --card:#fff; --line:#e5e7eb; --accent:#0a60ff; --good:#0b7; --warn:#b60; --bad:#c33 }
    *{box-sizing:border-box}
    body{font-family:System-ui,Segoe UI,Roboto,Arial,sans-serif;margin:0;background:var(--bg);color:var(--fg)}
    header{border-bottom:1px solid var(--line);background:var(--card)}
    header .wrap{max-width:1000px;margin:0 auto;padding:14px 16px;display:flex;gap:12px;align-items:center;justify-content:space-between}
    h1{font-size:18px;margin:0}
    .muted{color:var(--muted)}
    main{max-width:1000px;margin:20px auto;padding:0 16px 64px}
    .card{background:var(--card);border:1px solid var(--line);border-radius:14px;padding:14px;box-shadow:0 1px 2px rgba(0,0,0,.03)}
    .row{display:flex;gap:12px;flex-wrap:wrap}
    .grow{flex:1 1 280px}
    input[type="text"], input[type="url"], select{width:100%;padding:10px 12px;border:1px solid var(--line);border-radius:10px}
    button{border:0;background:var(--accent);color:#fff;padding:10px 14px;border-radius:12px;cursor:pointer}
    button.secondary{background:#eef2ff;color:#1e40af}
    table{width:100%;border-collapse:collapse}
    th,td{padding:8px 10px;border-bottom:1px solid var(--line);vertical-align:top}
    th{text-align:left;background:#fafafa}
    .pill{display:inline-block;padding:2px 8px;border-radius:999px;font-size:12px;border:1px solid var(--line)}
    .ok{background:#ecfdf5;border-color:#d1fae5;color:#065f46}
    .warn{background:#fff7ed;border-color:#ffedd5;color:#9a3412}
    .bad{background:#fef2f2;border-color:#fee2e2;color:#991b1b}
    details{border:1px dashed var(--line);border-radius:12px;padding:8px 10px;background:#fcfcff}
    details[open]{background:#f8fbff}
    summary{cursor:pointer;font-weight:600}
    .kbd{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace; font-size:12px; border:1px solid var(--line); padding:0 6px; border-radius:6px; background:#fafafa}
    .small{font-size:12px}
    .right{margin-left:auto}
    .tag{display:inline-block;padding:2px 6px;border:1px solid var(--line);border-radius:8px;margin-right:4px;background:#fafafa}
    .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace}
  </style>
</head>
<body>
  <header>
    <div class="wrap">
      <h1>Brain Healthy Nutrition Tables <span class="muted">— CSV Normalizer</span></h1>
      <div class="small muted">Open <span class="kbd">Ctrl</span>+<span class="kbd">Shift</span>+<span class="kbd">D</span> for Diagnostics</div>
    </div>
  </header>

  <main>
    <!--
      HOW TO USE (zero‑coding option for CSV locations)
      1) If your CSVs are stored next to this file (e.g., /data/*.csv or same folder), try clicking "Reload Data" now.
      2) If they are in WordPress Media Library (e.g., https://YOUR-SITE/wp-content/uploads/2025/08/),
         paste that BASE URL below (keep the trailing /), then click Reload.
      3) The file names we expect (you can change them in Settings):
         categories.csv, diet_tool.csv, fiber.csv, gi_gl.csv, main.csv, microbiome.csv,
         micronutients_list.csv, micronutrients_food.csv, moder.csv, protein.csv
    -->

    <section class="card" id="settings">
      <div class="row">
        <div class="grow">
          <label class="small muted">CSV Base URL (leave empty to load from this same folder)</label>
          <input type="url" id="baseUrl" placeholder="e.g., https://your-site.com/wp-content/uploads/2025/08/" />
        </div>
        <div>
          <label class="small muted" style="visibility:hidden">_</label>
          <button id="reloadBtn">Reload Data</button>
        </div>
      </div>
      <div class="small muted" style="margin-top:8px">You can move this whole file anywhere. Just keep your CSVs reachable (same folder or a public URL). No other changes needed.</div>
    </section>

    <div style="height:12px"></div>

    <section class="card">
      <div class="row">
        <div class="grow">
          <label class="small muted">Find a food</label>
          <input type="text" id="foodSearch" list="foodList" placeholder="Start typing (e.g., Arugula, Almond Milk, Eggs)" />
          <datalist id="foodList"></datalist>
        </div>
        <div>
          <label class="small muted" style="visibility:hidden">_</label>
          <button id="showBtn" class="secondary">Show Nutrition</button>
        </div>
      </div>
      <div id="status" class="small muted" style="margin-top:8px">Status: <span id="statusText">Waiting for data…</span></div>
    </section>

    <div style="height:12px"></div>

    <section class="card" id="results" style="display:none">
      <h2 style="margin:0 0 8px">Nutrition Table</h2>
      <div id="metaTags" style="margin-bottom:8px"></div>
      <table id="nutritionTable"></table>
    </section>

    <div style="height:12px"></div>

    <details id="diagnostics" style="display:none">
      <summary>Diagnostics (Developer View)</summary>
      <div class="small muted" style="margin:8px 0">Press <span class="kbd">Ctrl</span>+<span class="kbd">Shift</span>+<span class="kbd">D</span> to toggle this section.</div>
      <div id="diagContent" class="mono" style="white-space:pre-wrap"></div>
    </details>
  </main>

  <!-- d3-dsv (CSV parser) — embedded minified to keep this file standalone -->
  <script>
  // Minimal d3-dsv csvParse (MIT) — trimmed for csv only
  // Source: https://github.com/d3/d3-dsv (inlined for one-file deploy)
  (function(global){
    function objectConverter(columns){ return new Function("d","return {" + columns.map(function(name,i){
      return JSON.stringify(name) + ": d["+i+"]"; }).join(",") + "}" ); }
    function inferColumns(rows){ var columnSet = Object.create(null), columns=[]; rows.forEach(function(row){
      for (var i=0,n=row.length;i<n;++i){ var value=row[i], name=columns[i] || (columns[i] = i+""); if (value==null) continue; } });
      return columns; }
    function parseRows(text, f){ var EOL={}, EOF={}, N = text.length, I = 0, n = 0, t, eol;
      function token(){ if (I >= N) return EOF; if (eol) return eol = false, EOL; var j = I; if (text.charCodeAt(j) === 34){ var i = j; while (i++ < N){ if (text.charCodeAt(i) === 34){ if (text.charCodeAt(i+1) !== 34) break; ++i; } } I = i + 2; var c = text.charCodeAt(i+1); if (c === 13){ eol = true; if (text.charCodeAt(i+2) === 10) ++I; } else if (c === 10){ eol = true; } return text.slice(j+1, i).replace(/""/g, '"'); }
        while (I < N){ var c = text.charCodeAt(I++); if (c === 10) { eol = true; break; } if (c === 13){ eol = true; if (text.charCodeAt(I) === 10) ++I; break; } if (c === 44) break; } return text.slice(j, I - (eol || text.charCodeAt(I-1) === 44 ? 1 : 0)); }
      var rows = []; var row = []; var r; while ((r = token()) !== EOF){ if (r === EOL){ if (f && (row = f(row, n++)) == null) row = []; else rows.push(row); row = []; } else row.push(r); } if (f && (row = f(row, n++)) == null) return rows; rows.push(row); return rows; }
    function autoType(object){ for (var k in object){ var v = object[k]; if (v === "" || v == null) continue; var n = +v; if (!isNaN(n) && v.trim() !== "") object[k] = v.includes(".") ? n : n; } return object; }
    function csvParse(text){ var header; return parseRows(text, function(row, i){ if (!i){ header = row; return; } var o = {}; for (var j=0; j<header.length; ++j){ o[header[j]] = row[j] === undefined ? "" : row[j]; } return o; }); }
    global.csvParse = csvParse;
  })(window);
  </script>

  <script>
  // ===== Utility: Canonicalization and Parsing =====
  const U = {
    canonHeader(h){ if(h==null) return null; return String(h)
      .normalize("NFKD").replace(/[\u0300-\u036f]/g,"")
      .toLowerCase().replace(/[\u00a0\u2007\u202f]/g," ")
      .trim().replace(/[^\w]+/g,"_").replace(/_+/g,"_").replace(/^_|_$/g,""); },
    canonFoodName(s){ if(!s) return null; return String(s)
      .normalize("NFKD").replace(/[\u0300-\u036f]/g,"")
      .toLowerCase().replace(/&/g,"and").replace(/[^a-z0-9]+/g," ")
      .trim().replace(/\s+/g," "); },
    parseNumber(v){ if(v==null) return null; let s = String(v).trim();
      if(!s || s === '" "') return null; // handles odd '" "' placeholders
      // remove unicode dashes, angle markers, approx
      s = s.replace(/[—–−]/g,'-').replace(/[<>≈~]/g,'');
      // remove units
      s = s.replace(/\s?(kcal|cal|kj|g|mg|mcg|µg|ug|grams?|milligrams?|micrograms?)\b/gi,"");
      // replace comma decimal and thousands
      s = s.replace(/,(?=\d{3}\b)/g,'').replace(',', '.');
      // map trace and similar
      if(/^trace$/i.test(s)) return 0.05; // small but non-zero if you prefer 0, change here
      if(/^na$/i.test(s)) return null;
      s = s.replace(/[^0-9+\-.eE]/g,'');
      if(!s) return null; const n = Number(s); return Number.isFinite(n) ? n : null; },
    isTruthy(v){ if(v==null) return false; const s = String(v).trim(); if(!s) return false; if(s === '" "') return false; if(/^0$/.test(s)) return false; return true; },
  };

  // ===== Configurable file list (filenames only) =====
  const FILES = [
    'categories.csv',
    'diet_tool.csv',
    'fiber.csv',
    'gi_gl.csv',
    'main.csv',
    'microbiome.csv',
    'micronutients_list.csv', // note: spelling as provided
    'micronutrients_food.csv',
    'moder.csv',
    'protein.csv'
  ];

  // ===== Header Synonyms (canonical_key -> list of acceptable header patterns) =====
  const H = {
    // identity keys
    food_name: ['foods','food','ingredient','item','name','product'],

    // core nutrition
    energy_kcal: ['energy_kcal','calories','kcal','energy'],
    protein_g: ['protein_g','protein_per_serving_g','protein_per_100g_g','protein'],
    fiber_g: ['fiber_g','total_fiber_g','dietary_fiber_g','fibre_g','fiber'],
    carbs_g: ['carbs_g','carbohydrate_g','carbohydrates_g','carb_g','carbohydrate'],
    fat_g: ['fat_g','total_fat_g','fat'],
    sugars_g: ['sugars_g','sugar_g','total_sugars_g'],
    sodium_mg: ['sodium_mg','na_mg'],
    gi: ['glycemic_index_gi','gi'],
    gl: ['glycemic_load_per_serving','glycemic_load','gl'],
    serving_size: ['serving_size','serving_size_estimation','serving_size_g'],

    // scoring/tags
    dii_score: ['dii_score','dii'],
    microbiome_supporting: ['microbiome_supporting'],
    mind: ['mind','✓mind'],
    mediterranean: ['mediterranean','✓mediterranean'],
    dash: ['dash','✓dash'],

    // descriptive
    key_micronutrients: ['key_micronutrients_bioactive_compounds','key_micronutrients_bioactive_compounds_'],
    cognitive_benefits: ['direct_indirect_cognitive_benefits','direct_cognitive_benefits','inirect_cognitive_benefits','indirect_cognitive_benefits'],
    mechanisms: ['supporting_mechanisms','mechanism_function'],
    category: ['category'],
  };

  // Build quick reverse lookup from canonicalized header to canonical key
  function buildHeaderMap(headers){
    const map = {}; // canonHeader -> canonical_key
    const canonHeaders = headers.map(U.canonHeader);
    for(const [canonKey, list] of Object.entries(H)){
      for(const candidate of list){
        const idx = canonHeaders.indexOf(candidate);
        if(idx !== -1){ map[candidate] = canonKey; }
      }
    }
    return map; // not all headers will be mapped; we only use known ones
  }

  // ===== Data store =====
  const Store = {
    baseUrl: '',
    rawByFile: {},
    mergedByFood: new Map(), // key: canonFoodName -> record object
    foodsList: [],
    headerAudit: {},
  };

  // ===== Fetch & Parse =====
  async function fetchText(url){
    const res = await fetch(url, { cache: 'no-store' });
    if(!res.ok) throw new Error('HTTP '+res.status+' for '+url);
    return await res.text();
  }

  async function loadAll(){
    const base = Store.baseUrl.trim();
    const urls = FILES.map(f => base ? base + f : f);
    const results = await Promise.allSettled(urls.map(u => fetchText(u)));
    Store.rawByFile = {};
    const diag = [];
    for(let i=0;i<urls.length;i++){
      const fname = FILES[i];
      const r = results[i];
      if(r.status === 'fulfilled'){
        const text = r.value; const rows = window.csvParse(text);
        Store.rawByFile[fname] = rows;
        diag.push(`✔ Loaded ${fname} (${rows.length} rows)`);
      } else {
        diag.push(`✖ Failed ${fname}: ${r.reason}`);
      }
    }
    document.getElementById('diagContent').textContent = diag.join('\n');
  }

  // ===== Merge logic =====
  function mergeAll(){
    Store.mergedByFood = new Map();
    Store.headerAudit = {};

    for(const [fname, rows] of Object.entries(Store.rawByFile)){
      if(!rows || !rows.length) continue;
      const headers = Object.keys(rows[0] || {});
      const canonHeaders = headers.map(U.canonHeader);
      const headerMap = buildHeaderMap(headers);
      Store.headerAudit[fname] = { headers, canonHeaders, headerMap };

      for(const row of rows){
        // find the best name column
        let rawName = null; let rawKeyCol = null;
        for(const nameCol of (H.food_name||[])){
          const idx = canonHeaders.indexOf(nameCol);
          if(idx !== -1){ const colName = headers[idx]; rawName = row[colName]; rawKeyCol = colName; break; }
        }
        if(!rawName){ continue; }
        const key = U.canonFoodName(rawName);
        if(!key) continue;

        // init record
        const rec = Store.mergedByFood.get(key) || { __names:new Set(), __sources:new Set() };
        rec.__names.add(String(rawName).trim());
        rec.__sources.add(fname);

        // transfer known columns
        for(let j=0;j<headers.length;j++){
          const orig = headers[j]; const canon = U.canonHeader(orig);
          const canonKey = headerMap[canon]; if(!canonKey) continue;
          const val = row[orig];
          switch(canonKey){
            case 'protein_g':
            case 'fiber_g':
            case 'carbs_g':
            case 'fat_g':
            case 'sugars_g':
            case 'sodium_mg':
            case 'energy_kcal':
            case 'gi':
            case 'gl':
              {
                const n = U.parseNumber(val);
                if(n===0 || Number.isFinite(n)){
                  // prefer keeping an existing finite value; override only if undefined
                  if(!(canonKey in rec) || rec[canonKey]==null){ rec[canonKey] = n; }
                }
              }
              break;
            case 'serving_size':
              {
                const s = String(val||'').trim(); if(s){ rec.serving_size = s; }
              }
              break;
            case 'dii_score':
              {
                const n = U.parseNumber(val);
                if(n===0 || Number.isFinite(n)){
                  if(!(canonKey in rec) || rec[canonKey]==null){ rec[canonKey] = n; }
                }
              }
              break;
            case 'microbiome_supporting':
            case 'mind':
            case 'mediterranean':
            case 'dash':
              if(U.isTruthy(val)) rec[canonKey] = true;
              break;
            case 'key_micronutrients':
            case 'cognitive_benefits':
            case 'mechanisms':
            case 'category':
              {
                const s = String(val||'').trim(); if(s){ rec[canonKey] = s; }
              }
              break;
          }
        }
        Store.mergedByFood.set(key, rec);
      }
    }

    // Build foodsList for the UI
    const set = new Set();
    for(const [k, rec] of Store.mergedByFood.entries()){
      // Pick a representative name to show
      const name = Array.from(rec.__names)[0] || k;
      set.add(name);
    }
    Store.foodsList = Array.from(set).sort((a,b)=>a.localeCompare(b));
  }

  // ===== UI Rendering =====
  function setStatus(msg){ document.getElementById('statusText').textContent = msg; }

  function populateDatalist(){
    const dl = document.getElementById('foodList');
    dl.innerHTML = '';
    for(const name of Store.foodsList){
      const opt = document.createElement('option'); opt.value = name; dl.appendChild(opt);
    }
  }

  function findRecordByName(name){
    if(!name) return null;
    const key = U.canonFoodName(name);
    if(Store.mergedByFood.has(key)) return Store.mergedByFood.get(key);
    // fallback: try relaxed matching (startsWith)
    const entry = Array.from(Store.mergedByFood.entries()).find(([k])=>k.startsWith(key));
    return entry ? entry[1] : null;
  }

  function renderTable(name){
    const rec = findRecordByName(name);
    const section = document.getElementById('results');
    const table = document.getElementById('nutritionTable');
    const tags = document.getElementById('metaTags');
    if(!rec){ section.style.display='none'; return; }

    // Tags
    const tagBits = [];
    if(rec.category) tagBits.push(`<span class="tag">${rec.category}</span>`);
    if(rec.mind) tagBits.push('<span class="tag">MIND</span>');
    if(rec.mediterranean) tagBits.push('<span class="tag">Mediterranean</span>');
    if(rec.dash) tagBits.push('<span class="tag">DASH</span>');
    if(rec.microbiome_supporting) tagBits.push('<span class="tag">Microbiome-supporting</span>');
    if(rec.key_micronutrients) tagBits.push(`<span class="tag">Micronutrients: ${rec.key_micronutrients}</span>`);
    if(rec.cognitive_benefits) tagBits.push(`<span class="tag">Benefits: ${rec.cognitive_benefits}</span>`);
    if(rec.mechanisms) tagBits.push(`<span class="tag">Mechanisms: ${rec.mechanisms}</span>`);
    tags.innerHTML = tagBits.join(' ');

    // Helper to print values preserving 0, but showing N/A for null/undefined
    const fmt = (v, unit='') => (v===0 || Number.isFinite(v)) ? `${v}${unit}` : 'N/A';

    table.innerHTML = `
      <thead>
        <tr><th>Field</th><th>Value</th><th>Source Files</th></tr>
      </thead>
      <tbody>
        <tr><td>Serving Size</td><td>${rec.serving_size || 'N/A'}</td><td rowspan="11" class="small muted">${Array.from(rec.__sources).join(', ')}</td></tr>
        <tr><td>Energy (kcal)</td><td>${fmt(rec.energy_kcal)}</td></tr>
        <tr><td>Protein (g)</td><td>${fmt(rec.protein_g)}</td></tr>
        <tr><td>Fiber (g)</td><td>${fmt(rec.fiber_g)}</td></tr>
        <tr><td>Carbohydrates (g)</td><td>${fmt(rec.carbs_g)}</td></tr>
        <tr><td>Fat (g)</td><td>${fmt(rec.fat_g)}</td></tr>
        <tr><td>Sugars (g)</td><td>${fmt(rec.sugars_g)}</td></tr>
        <tr><td>Sodium (mg)</td><td>${fmt(rec.sodium_mg)}</td></tr>
        <tr><td>Glycemic Index (GI)</td><td>${fmt(rec.gi)}</td></tr>
        <tr><td>Glycemic Load (per serving)</td><td>${fmt(rec.gl)}</td></tr>
        <tr><td>DII (Dietary Inflammatory Index)</td><td>${fmt(rec.dii_score)}</td></tr>
      </tbody>`;
    section.style.display = '';
  }

  // ===== Diagnostics UI =====
  function toggleDiagnostics(){
    const el = document.getElementById('diagnostics');
    el.style.display = (el.style.display === 'none' || !el.style.display) ? '' : 'none';
  }
  document.addEventListener('keydown', (e)=>{
    if(e.ctrlKey && e.shiftKey && e.key.toLowerCase()==='d'){
      toggleDiagnostics();
    }
  });

  function renderAudit(){
    const lines = [];
    for(const [fname, audit] of Object.entries(Store.headerAudit)){
      lines.push(`\n# ${fname}`);
      if(!audit){ lines.push('  (no data)'); continue; }
      lines.push('  Original headers:');
      for(const h of audit.headers){ lines.push('   • '+h); }
      lines.push('  Canonical headers:');
      for(const h of audit.canonHeaders){ lines.push('   • '+h); }
      lines.push('  Mapped → canonical keys:');
      for(const [canonHeader, canonKey] of Object.entries(audit.headerMap)){
        lines.push(`   • ${canonHeader}  →  ${canonKey}`);
      }
    }
    document.getElementById('diagContent').textContent += '\n' + lines.join('\n');
  }

  // ===== Boot =====
  async function boot(){
    setStatus('Loading CSVs…');
    await loadAll();
    setStatus('Merging & normalizing…');
    mergeAll();
    populateDatalist();
    setStatus('Ready. Type a food name and click “Show Nutrition”.');
    renderAudit();
  }

  // Events
  document.getElementById('reloadBtn').addEventListener('click', ()=>{
    Store.baseUrl = document.getElementById('baseUrl').value || '';
    boot().catch(err=>{ setStatus('Error: '+err.message); console.error(err); });
  });
  document.getElementById('showBtn').addEventListener('click', ()=>{
    const name = document.getElementById('foodSearch').value;
    renderTable(name);
  });

  // Auto-load once on first visit (no base URL)
  boot().catch(err=>{ setStatus('Error: '+err.message); console.error(err); });
  </script>
</body>
</html>
