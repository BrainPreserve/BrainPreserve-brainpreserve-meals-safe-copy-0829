<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Brain Healthy Meal Generator — Standalone (CSV-only)</title>
  <style>
    :root{ --bg:#f7f8fb; --fg:#111; --muted:#667085; --card:#fff; --line:#e5e7eb; --accent:#0a60ff; }
    *{box-sizing:border-box}
    body{font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;margin:0;background:var(--bg);color:var(--fg)}
    header{background:#fff;border-bottom:1px solid var(--line)}
    .wrap{max-width:1000px;margin:0 auto;padding:20px 16px}
    h1{margin:0 0 6px}
    p.sub{margin:0;color:var(--muted)}
    main{padding:24px 0}
    .card{background:var(--card);border:1px solid var(--line);border-radius:14px;padding:16px;margin-bottom:18px;box-shadow:0 1px 0 rgba(0,0,0,.02)}
    .row{display:flex;gap:14px;flex-wrap:wrap}
    .row>div{flex:1 1 320px}
    label{display:block;font-weight:600;margin:6px 0 6px}
    select, input[type="text"]{width:100%;border:1px solid var(--line);border-radius:10px;padding:8px;background:#fff}
    .btn{appearance:none;border:0;border-radius:999px;background:var(--accent);color:#fff;padding:10px 16px;font-weight:600;cursor:pointer}
    .btn:disabled{opacity:.5;cursor:not-allowed}
    .hint{color:var(--muted);font-size:13px}
    .status{font-size:13px;color:#0a7f2e}
    .err{color:#a62626}
    /* Markdown-like tables */
    .bp-table{border-collapse:collapse;width:100%;margin:12px 0 18px 0;font-size:14px}
    .bp-table th,.bp-table td{border:1px solid #e5e7eb;padding:6px 8px;vertical-align:top}
    .bp-table th{background:#f7f7fb;font-weight:600}
    .bp-total td{font-weight:700;background:#f9fafb}
    .bp-footnote{color:#667085;font-size:12px;margin:-6px 0 12px 0}
    .bp5stack h3{margin:18px 0 8px 0}
    th{word-break:break-word}
    .recipe{border:1px solid var(--line);border-radius:12px;padding:14px;margin:18px 0;background:#fff}
    .recipe h2{margin:0 0 6px}
    .recipe .ingredients{margin:8px 0 0 18px}
    .small{font-size:12px;color:var(--muted)}
  </style>

  <!-- PapaParse for CSV parsing -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
</head>
<body>
  <header>
    <div class="wrap">
      <h1>Brain Healthy Meal Generator — Standalone</h1>
      <p class="sub">Generates exactly 5 recipes and builds the 5 required tables from your 10 local CSV files. No GPT, no server.</p>
    </div>
  </header>

  <main>
    <div class="wrap">
      <div class="card">
        <div class="row">
          <div>
            <label for="mealType">Meal type</label>
            <select id="mealType">
              <option value="breakfast">Breakfast</option>
              <option value="lunch" selected>Lunch</option>
              <option value="dinner">Dinner</option>
            </select>
            <p class="hint">Deterministic rules (no randomness) → stable output.</p>
          </div>
          <div>
            <label for="exclusions">Exclude ingredients (comma-separated)</label>
            <input id="exclusions" type="text" placeholder="e.g., dairy, red meat">
            <p class="hint">Optional. Applied across all 5 recipes.</p>
          </div>
        </div>
        <div class="row" style="align-items:center">
          <div>
            <button id="genBtn" class="btn" onclick="window.generateRecipes && window.generateRecipes()">Generate 5 Recipes + Tables</button>
          </div>
          <div>
            <span id="status" class="status">Loading CSV data…</span>
          </div>
        </div>
      </div>

      <div id="output"></div>
    </div>
  </main>

  <script>
  (function(){
    "use strict";

    // ---------- CONFIG ----------
    const CSV_BASENAMES = [
      'categories.csv',
      'diet_tool.csv',
      'fiber.csv',
      'gi_gl.csv',
      'main.csv',
      'microbiome.csv',
      'micronutrients_list.csv',
      'micronutrients_food.csv',
      'moder.csv',
      'protein.csv'
    ];
    const DATA_ROOTS = ['data/','./data/','/data/']; // try relative first (works on Netlify subpaths)

    const COLS = {
      ingredient:     ['Ingredient','Ingredients','Food','Item','Name','Food Name','Ingredient Name'],
      category:       ['Category','Group','Food Group','Class'],
      calories:       ['Calories','kcal','Calories_per_serving'],
      protein_g:      ['Protein (g)','Protein_g','Protein'],
      fiber_g:        ['Fiber (g)','Fiber_g','Fiber'],
      gi:             ['GI','Glycemic Index'],
      gl:             ['GL','Glycemic Load'],
      dii:            ['DII Score','DII','AntiInflammatoryScore','Anti-Inflammatory/DII','Anti-Inflammatory/DII Score (lower is better)'],
      key_micros:     ['Key Micronutrients','Key Nutrients/Bioactives','Key_Nutrients'],
      micro_type:     ['Microbiome Prebiotic or Probiotic or Postbiotic','Microbiome_Type','Pre/Pro/Postbiotic','Microbiome Type'],
      micro_score:    ['Microbiome Benefit Score','Microbiome_Score','Benefit Score'],
      cog_benefits:   ['Cognitive Benefits & Mechanisms','Cognitive_Benefits','Cognition_Mechanisms'],
      other_benefits: ['Other Health Benefits','Other_Benefits'],
      diets_list:     ['Compatible Diets','Diets','Diet_Compat'],
      serving_size:   ['Serving Size','Serving','Common Serving'],
      mech_fn:        ['Mechanism/Function','Mechanism','Function'],
      sources_details:['Notable Sources/Details','Notes','Details']
    };

    const POSSIBLE_DIETS = ['MIND','Mediterranean','DASH','LowGI','Pescetarian','Vegetarian','Vegan','Keto','Paleo','GlutenFree','DairyFree','AntiInflammatory','Modern'];
    const NAME_ALIAS = {
      'extra virgin olive oil':'olive oil','ev olive oil':'olive oil',
      'rolled oats':'oats','baby spinach':'spinach','greek yogurt':'yogurt',
      'brown rice':'rice','wild salmon':'salmon','chickpeas':'garbanzo beans'
    };

    // ---------- STATE ----------
    const DB = { data:{}, byCategory:{}, csvRows:0, ready:false };

    // ---------- HELPERS ----------
    const $ = s => document.querySelector(s);
    const esc = s=>String(s).replace(/[&<>"']/g,m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
    const toKey = s => (s||'').toLowerCase().normalize('NFKD').replace(/[\u0300-\u036f]/g,'').replace(/[^a-z0-9\s\-]/g,'').replace(/\s+/g,' ').trim();
    const num = v => { if(v==null) return null; const x=parseFloat(String(v).replace(/[^\d\.\-]/g,'')); return Number.isFinite(x)?x:null; };
    const fmt = (v,d=0) => (v==null || !Number.isFinite(v) ? 'N/A' : (d===0 ? String(Math.round(v)) : v.toFixed(d)));
    const pick = (row, names) => { for (const n of names){ if(n in row && row[n]!=='' && row[n]!=null) return row[n]; } };
    const includesWord = (s,w)=> new RegExp(`\\b${w}\\b`,'i').test(String(s||''));
    const canonical = raw => {
      let s = String(raw||'').toLowerCase();
      s = s.replace(/\(.*?\)/g,'').replace(/\b(fresh|chopped|diced|minced|cooked|raw|organic|extra|virgin|ground|dry|dried|toasted|unsalted|salted|low\-fat|nonfat|skinless|boneless)\b/g,'');
      s = s.replace(/\s+/g,' ').trim();
      if (NAME_ALIAS[s]) s = NAME_ALIAS[s];
      if (s.endsWith('s') && !s.endsWith('ss')) s = s.slice(0,-1);
      return s;
    };
    function setStatus(msg, cls){ const el=$('#status'); el.textContent=msg; el.className = cls||'status'; }

    // ---------- CSV LOAD ----------
    function loadAllCSVs(){
      return new Promise(resolve=>{
        let remaining = CSV_BASENAMES.length;
        CSV_BASENAMES.forEach(name=>loadOneWithFallback(name,0,()=>{
          if(--remaining===0){ DB.ready=true; resolve(); }
        }));
      });
    }
    function loadOneWithFallback(name, i, done){
      if (i>=DATA_ROOTS.length){ done(); return; }
      const url = DATA_ROOTS[i] + name;
      Papa.parse(url,{
        download:true, header:true, skipEmptyLines:'greedy',
        complete:(res)=>{
          if (Array.isArray(res.data) && res.data.length){
            mergeRows(res.data);
            if (name==='categories.csv') indexCategories(res.data);
            done();
          } else {
            loadOneWithFallback(name, i+1, done);
          }
        },
        error:()=> loadOneWithFallback(name, i+1, done)
      });
    }
    function indexCategories(rows){
      for (const r0 of rows){
        const r={}; for (const k in r0) r[k.trim()] = r0[k];
        const name = pick(r, COLS.ingredient);
        const cat  = pick(r, COLS.category);
        if (!name || !cat) continue;
        const key = toKey(canonical(name));
        const ckey = String(cat).trim();
        if (!DB.byCategory[ckey]) DB.byCategory[ckey] = new Set();
        DB.byCategory[ckey].add(key);
      }
    }
    function mergeRows(rows){
      for (const r0 of rows){
        if(!r0) continue;
        const r={}; for (const k in r0) r[k.trim()] = r0[k];
        let name = pick(r, COLS.ingredient);
        if (!name){
          const keys = Object.keys(r);
          const guess = keys.find(k=>/ingredient|food|item|name/i.test(k)) || keys[0];
          name = r[guess];
        }
        if (!name) continue;
        const key = toKey(canonical(name));
        if (!DB.data[key]) DB.data[key] = { _name:name, _rows:[] };
        const dst = DB.data[key]; dst._rows.push(r); DB.csvRows++;

        const groups = [
          ['calories',COLS.calories],['protein_g',COLS.protein_g],['fiber_g',COLS.fiber_g],
          ['gi',COLS.gi],['gl',COLS.gl],['dii',COLS.dii],['key_micros',COLS.key_micros],
          ['micro_type',COLS.micro_type],['micro_score',COLS.micro_score],['cog_benefits',COLS.cog_benefits],
          ['other_benefits',COLS.other_benefits],['diets_list',COLS.diets_list],
          ['serving_size',COLS.serving_size],['mech_fn',COLS.mech_fn],['sources_details',COLS.sources_details],
          ['category',COLS.category]
        ];
        for (const [k,aliases] of groups){
          if (dst[k]==null){
            const v = pick(r, aliases);
            if (v!=null && String(v).trim()!=='') dst[k]=v;
          }
        }
      }
    }

    // ---------- POOLS & RECIPE ENGINE ----------
    const cat = (label)=> DB.byCategory[label] ? Array.from(DB.byCategory[label]).filter(k=>DB.data[k]) : [];
    const scan = (hints)=> {
      const out=new Set();
      for (const k in DB.data){
        const rec=DB.data[k];
        const nm=(rec._name||'').toLowerCase();
        const cg=(rec.category||'').toLowerCase();
        if (hints.some(h=>includesWord(nm,h)||includesWord(cg,h))) out.add(k);
      }
      return Array.from(out);
    };
    const uniq = a=>Array.from(new Set(a));

    function poolVegetables(){ return uniq([...cat('Vegetables'), ...scan(['vegetable','green','broccoli','kale','spinach','lettuce','pepper','onion','tomato'])]); }
    function poolWholeGrains(){ return uniq([...cat('Whole Grains'), ...scan(['oat','oats','quinoa','brown','rice','barley','farro','buckwheat','whole','grain'])]); }
    function poolLegumes(){ return uniq([...cat('Legumes'), ...scan(['bean','lentil','chickpea','soy','edamame','legume'])]); }
    function poolFish(){ return uniq([...cat('Fish'), ...scan(['salmon','sardine','mackerel','trout','tuna','fish'])]); }
    function poolMeat(){ return uniq([...cat('Meat'), ...scan(['chicken','turkey','beef','pork','meat'])]); }
    function poolNutsSeeds(){ return uniq([...cat('Nuts/Seeds'), ...scan(['almond','walnut','pecan','seed','pumpkin','chia','flax','hemp','nut'])]); }
    function poolOils(){ return uniq([...cat('Oils'), ...scan(['oil','olive','avocado oil','extra virgin'])]); }
    function poolDairy(){ return uniq([...cat('Dairy'), ...scan(['yogurt','kefir','milk','cheese','dairy'])]); }
    function poolFruit(){ return uniq([...cat('Fruit'), ...scan(['berry','apple','banana','grape','orange','fruit'])]); }
    function poolOther(){ return uniq([...cat('Other Ingredients'), ...scan(['spice','herb','garlic','ginger','vinegar','lemon','coffee','tea','egg','honey'])]); }

    function chooseDet(keys, n, avoidSet){
      const arr = keys.filter(k=>!avoidSet.has(k))
                      .sort((a,b)=>DB.data[a]._name.localeCompare(DB.data[b]._name));
      return arr.slice(0, Math.max(0,n));
    }
    function padFromAll(current, need, avoidSet){
      if (need<=0) return [];
      const arr = Object.keys(DB.data)
        .filter(k=>!avoidSet.has(k) && !current.includes(k))
        .sort((a,b)=>DB.data[a]._name.localeCompare(DB.data[b]._name));
      return arr.slice(0, need);
    }
    function firstName(k){ return k && DB.data[k] ? DB.data[k]._name : null; }
    function capFirst(s){ return s ? s.charAt(0).toUpperCase()+s.slice(1) : s; }
    const wordList = s => (s||'').split(',').map(x=>x.trim().toLowerCase()).filter(Boolean);

    function buildOneRecipe(mealType, exclusionsWords){
      const avoid = new Set();
      // Apply exclusions by name
      for (const k in DB.data){
        const nm = DB.data[k]._name.toLowerCase();
        if (exclusionsWords.some(w=>includesWord(nm,w))) avoid.add(k);
      }

      const veg = poolVegetables();
      const grains = poolWholeGrains();
      const legumes = poolLegumes();
      const fish = poolFish();
      const meat = poolMeat();
      const nuts = poolNutsSeeds();
      const oils = poolOils();
      const dairy = poolDairy();
      const fruit = poolFruit();

      let picks = [];
      if (mealType==='breakfast'){
        let base = chooseDet(grains.length?grains:legumes, 1, avoid);
        let topFruit = chooseDet(fruit,1,avoid);
        let topNuts = chooseDet(nuts,1,avoid);
        let dairyOpt = chooseDet(dairy,1,avoid);
        picks = [...base, ...topFruit, ...topNuts, ...dairyOpt];
        const missing = Math.max(0, 5 - picks.length);
        if (missing>0) picks = [...picks, ...padFromAll(picks, missing, avoid)];
      } else {
        // lunch/dinner: base + protein + 2 veg + oil + nuts (aim 6–7 items)
        const base = chooseDet(grains.length?grains:legumes,1,avoid);
        const protein = chooseDet([...fish, ...meat, ...legumes],1,avoid);
        const vegs = chooseDet(veg,2,avoid);
        const oil = chooseDet(oils,1,avoid);
        const nut = chooseDet(nuts,1,avoid);
        picks = [...base, ...protein, ...vegs, ...oil, ...nut];
        const missing = Math.max(0, 6 - picks.length);
        if (missing>0) picks = [...picks, ...padFromAll(picks, missing, avoid)];
      }

      // Deduplicate
      const seen=new Set(); picks = picks.filter(k=>k && !seen.has(k) && seen.add(k));

      // Human-friendly amounts (best-effort)
      const lines = picks.map(k=>{
        const nm = firstName(k) || 'Ingredient';
        const low = nm.toLowerCase();
        let amt = '1 serving';
        if (/oil/.test(low)) amt='1 Tbsp';
        else if (/(almond|walnut|seed|chia|flax|hemp|nuts?)/.test(low)) amt='1 oz';
        else if (/(yogurt|kefir)/.test(low)) amt='3/4 cup';
        else if (/(oat|quinoa|rice|barley|farro|buckwheat)/.test(low)) amt='3/4 cup cooked';
        else if (/(salmon|chicken|turkey|tuna|beef|pork)/.test(low)) amt='4 oz';
        else if (/(spinach|kale|broccoli|greens?)/.test(low)) amt='1 cup';
        else if (/(berry|banana|apple|fruit)/.test(low)) amt='1 cup';
        return `${amt} ${nm}`;
      });

      const title = mealType==='breakfast'
        ? `Brain-Healthy Breakfast Bowl with ${firstName(picks[0]) || 'Oats'}`
        : `Brain-Healthy ${capFirst(mealType)} Bowl with ${firstName(picks[1]) || 'Legumes'} & ${firstName(picks[2]) || 'Greens'}`;

      return { title, keys:picks, lines };
    }

    // ---------- TABLES ----------
    function buildAllTables(keys){
      const rows = keys.map(k => ({ key:k, rec:DB.data[k], display:firstName(k)||k }))
                       .sort((a,b)=>a.display.localeCompare(b.display));
      return `
        ${buildNutritionTable(rows)}
        ${buildCogTable(rows)}
        ${buildDietTable(rows)}
        ${buildMicrobiomeTable(rows)}
        ${buildMicronutrientBenefitsTable(rows)}
      `;
    }
    function buildNutritionTable(rows){
      let totCal=0, totProt=0, totFib=0, totGL=0;
      const body = rows.map(r=>{
        const d=r.rec||{};
        const cal=num(d.calories); if(cal!=null) totCal+=cal;
        const pr=num(d.protein_g); if(pr!=null) totProt+=pr;
        const fi=num(d.fiber_g);   if(fi!=null) totFib+=fi;
        const gi=num(d.gi);
        const gl=num(d.gl);        if(gl!=null) totGL+=gl;
        const dii = (d.dii!=null && String(d.dii).trim()!=='') ? d.dii : 'N/A';
        const keyMicros = d.key_micros ?? 'N/A';
        const mType = d.micro_type ?? 'N/A';
        const mScore = d.micro_score ?? 'N/A';
        return `<tr>
          <td>${esc(r.display)}</td>
          <td>${fmt(cal)}</td>
          <td>${fmt(pr)}</td>
          <td>${fmt(fi)}</td>
          <td>${gi==null?'N/A':fmt(gi)}</td>
          <td>${gl==null?'N/A':fmt(gl)}</td>
          <td>${esc(String(dii))}</td>
          <td>${esc(String(keyMicros))}</td>
          <td>${esc(String(mType))}</td>
          <td>${esc(String(mScore))}</td>
        </tr>`;
      }).join('');
      const totals = `<tr class="bp-total">
        <td>Totals</td><td>${fmt(totCal)}</td><td>${fmt(totProt)}</td><td>${fmt(totFib)}</td><td>—</td><td>${fmt(totGL)}</td><td>—</td><td>—</td><td>—</td><td>—</td>
      </tr>`;
      return `
        <h3>1. Nutrition Table</h3>
        <table class="bp-table">
          <thead>
            <tr>
              <th>Ingredient</th>
              <th>Calories</th>
              <th>Protein (g)</th>
              <th>Fiber (g)</th>
              <th>GI</th>
              <th>GL</th>
              <th>Anti-Inflammatory/<wbr>DII Score<br>(lower is better)</th>
              <th>Key Micronutrients</th>
              <th>Microbiome Prebiotic or Probiotic or Postbiotic</th>
              <th>Microbiome Benefit Score</th>
            </tr>
          </thead>
          <tbody>${body}${totals}</tbody>
        </table>
        <div class="bp-footnote">Totals sum Calories, Protein, Fiber, and GL. GI and DII are not additive (“—”). “N/A” appears when data are unavailable.</div>
      `;
    }
    function buildCogTable(rows){
      const body = rows.map(r=>{
        const d=r.rec||{};
        return `<tr><td>${esc(r.display)}</td><td>${esc(d.cog_benefits ?? 'N/A')}</td><td>${esc(d.other_benefits ?? 'N/A')}</td></tr>`;
      }).join('');
      return `
        <h3>2. Cognitive &amp; Other Health Benefits Table</h3>
        <table class="bp-table">
          <thead><tr><th>Ingredient</th><th>Cognitive Benefits &amp; Mechanisms</th><th>Other Health Benefits</th></tr></thead>
          <tbody>${body}</tbody>
        </table>
      `;
    }
    function buildDietTable(rows){
      const body = rows.map(r=>{
        const d=r.rec||{};
        let diets = d.diets_list;
        if (!diets) diets = deriveDietList(d._rows || []);
        return `<tr><td>${esc(r.display)}</td><td>${esc(diets ? String(diets) : 'N/A')}</td></tr>`;
      }).join('');
      return `
        <h3>3. Diet Compatibility Table</h3>
        <table class="bp-table">
          <thead><tr><th>Ingredient</th><th>Compatible Diets</th></tr></thead>
          <tbody>${body}</tbody>
        </table>
      `;
    }
    function deriveDietList(rows){
      if(!rows.length) return null;
      const yes=new Set();
      for (const r of rows){
        for (const d of POSSIBLE_DIETS){
          if (d in r){
            const v = String(r[d]).toLowerCase();
            if (['1','y','yes','true','✓','x'].includes(v)) yes.add(d);
          }
        }
      }
      return yes.size ? Array.from(yes).sort().join(', ') : null;
    }
    function buildMicrobiomeTable(rows){
      const body = rows.map(r=>{
        const d=r.rec||{};
        return `<tr><td>${esc(r.display)}</td><td>${esc(d.micro_type ?? 'N/A')}</td><td>${esc(d.micro_score ?? 'N/A')}</td></tr>`;
      }).join('');
      return `
        <h3>4. Microbiome Benefit Table</h3>
        <table class="bp-table">
          <thead><tr><th>Ingredient</th><th>Microbiome Prebiotic or Probiotic or Postbiotic</th><th>Microbiome Benefit Score</th></tr></thead>
          <tbody>${body}</tbody>
        </table>
      `;
    }
    function buildMicronutrientBenefitsTable(rows){
      const body = rows.map(r=>{
        const d=r.rec||{};
        const serving = d.serving_size ?? 'N/A';
        const keyN = d.key_micros ?? 'N/A';
        const mech = d.mech_fn ?? 'N/A';
        const srcs = d.sources_details ?? 'N/A';
        const pct = estimatePercentRDA(d);
        return `<tr><td>${esc(r.display)}</td><td>${esc(serving)}</td><td>${esc(keyN)}</td><td>${esc(mech)}</td><td>${esc(srcs)}</td><td>${esc(pct ?? 'N/A')}</td></tr>`;
      }).join('');
      return `
        <h3>5. Micronutrient Benefits Table</h3>
        <table class="bp-table">
          <thead>
            <tr>
              <th>Ingredient</th>
              <th>Serving Size</th>
              <th>Key Nutrients/Bioactives</th>
              <th>Mechanism/Function</th>
              <th>Notable Sources/Details</th>
              <th>% Recommended Daily Amount</th>
            </tr>
          </thead>
          <tbody>${body}</tbody>
        </table>
        <div class="bp-footnote">%RDA shown only when present/derivable in CSVs; otherwise “N/A”.</div>
      `;
    }
    function estimatePercentRDA(rec){
      try{
        const rows = rec._rows || [];
        for (const row of rows){
          for (const k in row){
            const key = k.toLowerCase();
            if (/%\s*rda/.test(key) || /rda_%/.test(key) || /percent[_\s]?rda/.test(key)){
              const v = num(row[k]); if (v!=null) return fmt(v);
            }
          }
        }
        return null;
      } catch { return null; }
    }

    // ---------- RENDER ----------
    function renderRecipes(mealType, exclusionsCsv){
      const out = $('#output'); out.innerHTML='';
      const excl = exclusionsCsv ? exclusionsCsv.split(',').map(s=>s.trim().toLowerCase()).filter(Boolean) : [];

      // Build 5 recipes (deterministic, with robust fallbacks)
      const recipes=[];
      for (let i=0;i<5;i++) recipes.push(buildOneRecipe(mealType, excl));

      recipes.forEach((R,i)=>{
        const sec = document.createElement('section');
        sec.className='recipe';
        sec.innerHTML = `
          <h2>${esc(R.title)}</h2>
          <div class="small">Recipe ${i+1} of 5</div>
          <h3>Ingredients</h3>
          <ul class="ingredients">${R.lines.map(li=>`<li>${esc(li)}</li>`).join('')}</ul>
          ${buildAllTables(R.keys)}
        `;
        out.appendChild(sec);
      });
    }

    // ---------- INIT ----------
    document.addEventListener('DOMContentLoaded', async ()=>{
      setStatus('Loading CSV data…','status');
      await loadAllCSVs();
      if (DB.csvRows===0){ setStatus('No CSV data found. Ensure a folder named “data” sits next to index.html with the 10 CSVs.','err'); return; }
      setStatus('CSV data loaded. Ready.','status');

      // Expose generator for the button’s inline onclick (guarantees the click works)
      window.generateRecipes = function(){
        if (!DB.ready || DB.csvRows===0){ setStatus('CSV data missing — cannot generate.','err'); return; }
        renderRecipes($('#mealType').value, $('#exclusions').value);
        setStatus('Done.','status');
      };
    });
  })();
  </script>
</body>
</html>
